

#[ macro_export ]
macro_rules! issue_tracking_check {
	( OK ) => ();
	( issue_optional ) => ();
	( issue_mandatory ) => (
		#[ cfg ( vonuvoli_lints_issue_tracking ) ]
		compile_error! ("issue tracking is mandatory!");
	);
	( github_issue_new ) => ();
	( ( github_issue, $code : expr ) ) => ();
}


#[ macro_export ]
macro_rules! issue_tracking_message {
	( OK ) => (
		{
			issue_tracking_check! (OK);
			None
		}
	);
	( issue_optional ) => (
		{
			issue_tracking_check! (issue_optional);
			None
		}
	);
	( issue_mandatory ) => (
		{
			issue_tracking_check! (issue_mandatory);
			None
		}
	);
	( github_issue_new ) => (
		{
			issue_tracking_check! (github_issue_new);
			Some (
				concat! (
					"you have encountered an unexpected issue!  ",
					"please report this issue at:  ",
					"https://github.com/volution/vonuvoli-scheme/issues/new"
				))
		}
	);
	( ( github_issue, $code : expr ) ) => (
		{
			issue_tracking_check! ((github_issue, $code));
			Some (
				concat! (
					"you have encountered an already known issue!  ",
					"for further details, please access this issue at:  ",
					"https://github.com/volution/vonuvoli-scheme/issues/", $code
				))
		}
	);
}




#[ macro_export ]
macro_rules! markup {
	( $type : ident, $message : expr ) => (
		markup! ($type, $message, issue_mandatory);
	);
	( $type : ident, $message : expr, $tracking : tt ) => (
		issue_tracking_check! ($tracking);
	);
}

#[ macro_export ]
macro_rules! FIXME {
	( $message : tt ) => (
		FIXME! ($message, issue_optional);
	);
	( $message : tt, $tracking : tt ) => (
		markup! (fixme, $message, $tracking);
	);
}

#[ macro_export ]
macro_rules! TODO {
	( $message : expr ) => (
		TODO! ($message, issue_optional);
	);
	( $message : expr, $tracking : tt ) => (
		markup! (todo, $message, $tracking);
	);
}




#[ macro_export ]
macro_rules! panic_with_error {
	( $error : expr, $code : expr ) => (
		panic_with_error! ($error, $code, issue_mandatory)
	);
	( $error : expr, $code : expr, $tracking : tt ) => (
		$crate::exports::panic_with_error ($error, $code, &(file! (), line! (), 0), issue_tracking_message! ($tracking));
	);
}




#[ macro_export ]
macro_rules! panic_0 {
	( $code : expr ) => (
		panic_0! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		panic_with_error! ($crate::exports::error_panic ($code, issue_tracking_message! ($tracking)), $code, $tracking)
	);
}

// #[ macro_export ]
macro_rules! panic {
	( $( _ : tt )* ) => (
		compile_error! ("`panic!` macro is dissalowed!  use `panic_0!` macro instead!")
	);
}


#[ macro_export ]
macro_rules! unreachable_0 {
	( $code : expr ) => (
		unreachable_0! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		panic_with_error! ($crate::exports::error_panic ($code, issue_tracking_message! ($tracking)), $code, $tracking)
	);
}

// #[ macro_export ]
macro_rules! unreachable {
	( $( _ : tt )* ) => (
		compile_error! ("`unreachable!` macro is dissalowed!  use `unreachable_0!` macro instead!")
	);
}


#[ macro_export ]
macro_rules! unimplemented_0 {
	( $code : expr ) => (
		unimplemented_0! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		panic_with_error! ($crate::exports::error_unimplemented ($code, issue_tracking_message! ($tracking)), $code, $tracking)
	);
}

// #[ macro_export ]
macro_rules! unimplemented {
	( $( _ : tt )* ) => (
		compile_error! ("`unimplemented!` macro is dissalowed!  use `unimplemented_0!` macro instead!")
	);
}


#[ macro_export ]
macro_rules! assert_0 {
	( $assertion : expr, $code : expr ) => (
		assert_0! ($assertion, $code, github_issue_new)
	);
	( $assertion : expr, $code : expr, $tracking : tt ) => (
		if ! $assertion {
			panic_0! ($code, $tracking);
		}
	);
}

// #[ macro_export ]
macro_rules! assert {
	( $( _ : tt )* ) => (
		compile_error! ("`assert!` macro is dissalowed!  use `assert_0!` macro instead!")
	);
}
// #[ macro_export ]
macro_rules! assert_eq {
	( $( _ : tt )* ) => (
		compile_error! ("`assert_eq!` macro is dissalowed!  use `assert_0!` macro instead!")
	);
}
// #[ macro_export ]
macro_rules! assert_ne {
	( $( _ : tt )* ) => (
		compile_error! ("`assert_ne!` macro is dissalowed!  use `assert_0!` macro instead!")
	);
}


#[ macro_export ]
macro_rules! debug_assert_0 {
	( $assertion : expr, $code : expr ) => (
		debug_assert_0! ($assertion, $code, github_issue_new)
	);
	( $assertion : expr, $code : expr, $tracking : tt ) => (
		{
			#[ cfg ( debug_assertions ) ]
			if ! $assertion {
				panic_0! ($code, $tracking);
			}
			#[ cfg ( not ( debug_assertions ) ) ]
			if false {
				panic_0! ($code, $tracking);
			}
		}
	);
}

// #[ macro_export ]
macro_rules! debug_assert {
	( $( _ : tt )* ) => (
		compile_error! ("`debug_assert!` macro is dissalowed!  use `debug_assert_0!` macro instead!")
	);
}
// #[ macro_export ]
macro_rules! debug_assert_eq {
	( $( _ : tt )* ) => (
		compile_error! ("`debug_assert_eq!` macro is dissalowed!  use `debug_assert_0!` macro instead!")
	);
}
// #[ macro_export ]
macro_rules! debug_assert_ne {
	( $( _ : tt )* ) => (
		compile_error! ("`debug_assert_ne!` macro is dissalowed!  use `debug_assert_0!` macro instead!")
	);
}




#[ macro_export ]
macro_rules! succeeded {
	( $outcome : expr ) => (
		$crate::prelude::Result::Ok ($outcome)
	);
}




#[ cfg ( feature = "vonuvoli_panic_on_failed" ) ]
#[ macro_export ]
macro_rules! failed_or_panic {
	( $code : expr, $outcome : expr ) => (
		failed_or_panic! ($code, $outcome, issue_mandatory)
	);
	( $code : expr, $outcome : expr, $tracking : tt ) => (
		panic_0! ($code, $tracking);
	);
}

#[ cfg ( not ( feature = "vonuvoli_panic_on_failed" ) ) ]
#[ macro_export ]
macro_rules! failed_or_panic {
	( $code : expr, $outcome : expr ) => (
		failed_or_panic! ($code, $outcome, issue_mandatory)
	);
	( $code : expr, $outcome : expr, $tracking : tt ) => (
		{
			issue_tracking_check! ($tracking);
			$outcome
		}
	);
}




#[ macro_export ]
macro_rules! failed {
	( $code : expr ) => (
		failed! ($code, issue_optional)
	);
	( $code : expr, $tracking : tt ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::exports::error_generic ($code, issue_tracking_message! ($tracking))), $tracking)
	);
}

#[ macro_export ]
macro_rules! failed_unimplemented {
	( $code : expr ) => (
		failed_unimplemented! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::exports::error_unimplemented ($code, issue_tracking_message! ($tracking))), $tracking)
	);
}

#[ macro_export ]
macro_rules! failed_panic {
	( $code : expr ) => (
		failed_panic! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::exports::error_panic ($code, issue_tracking_message! ($tracking))), $tracking)
	);
}

#[ macro_export ]
macro_rules! failed_unreachable {
	( $code : expr ) => (
		failed_unreachable! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		failed_or_panic! ($code, $crate::prelude::Result::Err ($crate::exports::error_panic ($code, issue_tracking_message! ($tracking))), $tracking)
	);
}




#[ macro_export ]
macro_rules! succeed {
	( $outcome : expr ) => (
		return succeeded! ($outcome);
	);
}




#[ macro_export ]
macro_rules! fail {
	( $code : expr ) => (
		fail! ($code, issue_optional)
	);
	( $code : expr, $tracking : tt ) => (
		#[ cfg_attr ( feature = "vonuvoli_panic_on_failed", allow (unreachable_code) ) ]
		return failed! ($code, $tracking);
	);
}

#[ macro_export ]
macro_rules! fail_unimplemented {
	( $code : expr ) => (
		fail_unimplemented! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		#[ cfg_attr ( feature = "vonuvoli_panic_on_failed", allow (unreachable_code) ) ]
		return failed_unimplemented! ($code, $tracking); // OK
	);
}

#[ macro_export ]
macro_rules! fail_panic {
	( $code : expr ) => (
		fail_panic! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		#[ cfg_attr ( feature = "vonuvoli_panic_on_failed", allow (unreachable_code) ) ]
		return failed_panic! ($code, $tracking); // OK
	);
}

#[ macro_export ]
macro_rules! fail_unreachable {
	( $code : expr ) => (
		fail_unreachable! ($code, issue_mandatory)
	);
	( $code : expr, $tracking : tt ) => (
		#[ cfg_attr ( feature = "vonuvoli_panic_on_failed", allow (unreachable_code) ) ]
		return failed_unreachable! ($code, $tracking); // OK
	);
}




#[ macro_export ]
macro_rules! succeed_or_fail {
	( $result : expr, $code : expr ) => (
		succeed_or_fail! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Result::Ok (value) = $result {
			succeed! (value);
		} else {
			fail! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_or_fail {
	( $result : expr, $code : expr ) => (
		try_or_fail! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Result::Ok (value) = $result {
			value
		} else {
			fail! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_or_panic {
	( $result : expr ) => (
		try_or_panic! ($result, issue_optional)
	);
	( $result : expr, $tracking : tt ) => (
		match $result {
			$crate::prelude::Result::Ok (value) =>
				value,
			$crate::prelude::Result::Err (error) =>
				panic_with_error! (error, 0x23553e5b, $tracking),
		}
	);
}

#[ macro_export ]
macro_rules! try_or_panic_0 {
	( $result : expr, $code : expr ) => (
		try_or_panic_0! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		match $result {
			$crate::prelude::Result::Ok (value) =>
				value,
			$crate::prelude::Result::Err (_) =>
				panic_0! ($code, $tracking),
		}
	);
}

#[ macro_export ]
macro_rules! try_or_return {
	( $result : expr, $default : expr ) => (
		if let $crate::prelude::Result::Ok (value) = $result {
			value
		} else {
			return $default;
		}
	);
}




#[ macro_export ]
macro_rules! enforce {
	( $expression : expr, $code : expr ) => (
		enforce! ($expression, $code, issue_optional)
	);
	( $expression : expr, $code : expr, $tracking : tt ) => (
		if !$expression {
			fail! ($code, $tracking);
		}
	);
}




#[ macro_export ]
macro_rules! try_some {
	( $option : expr, $code : expr ) => (
		try_some! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (value) = $option {
			value
		} else {
			fail! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_some_or_panic {
	( $option : expr, $code : expr ) => (
		try_some_or_panic! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (value) = $option {
			value
		} else {
			panic_0! ($code, $tracking);
		}
	);
}


#[ macro_export ]
macro_rules! try_some_ref {
	( $option : expr, $code : expr ) => (
		try_some_ref! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (ref value) = $option {
			value
		} else {
			fail! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_some_ref_or_panic {
	( $option : expr, $code : expr ) => (
		try_some_ref_or_panic! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (ref value) = $option {
			value
		} else {
			panic_0! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_some_ref_mut {
	( $option : expr, $code : expr ) => (
		try_some_ref_mut! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (ref mut value) = $option {
			value
		} else {
			fail! ($code, $tracking);
		}
	);
}

#[ macro_export ]
macro_rules! try_some_ref_mut_or_panic {
	( $option : expr, $code : expr ) => (
		try_some_ref_mut_or_panic! ($option, $code, issue_optional)
	);
	( $option : expr, $code : expr, $tracking : tt ) => (
		if let $crate::prelude::Option::Some (ref mut value) = $option {
			value
		} else {
			panic_0! ($code, $tracking);
		}
	);
}


#[ macro_export ]
macro_rules! try_some_2 {
	( $result : expr, $code : expr ) => (
		try_some_2! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some! (try! ($result), $code, $tracking)
	);
}

#[ macro_export ]
macro_rules! try_some_2_or_panic {
	( $result : expr, $code : expr ) => (
		try_some_2_or_panic! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some_or_panic! (try_or_panic! ($result, $tracking), $code, $tracking)
	);
}

#[ macro_export ]
macro_rules! try_some_ref_2 {
	( $result : expr, $code : expr ) => (
		try_some_ref_2! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some_ref! (try! ($result), $code, $tracking)
	);
}

#[ macro_export ]
macro_rules! try_some_ref_2_or_panic {
	( $result : expr, $code : expr ) => (
		try_some_ref_2_or_panic! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some_ref_or_panic! (try_or_panic! ($result, $tracking), $code, $tracking)
	);
}

#[ macro_export ]
macro_rules! try_some_ref_mut_2 {
	( $result : expr, $code : expr ) => (
		try_some_ref_mut_2! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some_ref_mut! (try! ($result), $code, $tracking)
	);
}

#[ macro_export ]
macro_rules! try_some_ref_mut_2_or_panic {
	( $result : expr, $code : expr ) => (
		try_some_ref_mut_2_or_panic! ($result, $code, issue_optional)
	);
	( $result : expr, $code : expr, $tracking : tt ) => (
		try_some_ref_mut_or_panic! (try_or_panic! ($result, $tracking), $code, $tracking)
	);
}




macro_rules! impl_into_for_outcome {
	( $from : ty ) => (
		impl_into_for_outcome! ($from, $from, value, value);
	);
	( $to : ty, $from : ty ) => (
		impl_into_for_outcome! ($to, $from, value, value);
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::exports::StdInto0<$crate::exports::Outcome<$to>> for $from {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn into_0 (self) -> ($crate::exports::Outcome<$to>) {
				let $value = self;
				succeed! ($crate::prelude::StdInto::<$to>::into ($expression));
			}
		}
		impl $crate::exports::StdInto0<$crate::exports::Outcome<$to>> for $crate::exports::Outcome<$from> {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn into_0 (self) -> ($crate::exports::Outcome<$to>) {
				match self {
					$crate::prelude::Result::Ok ($value) =>
						succeed! ($crate::prelude::StdInto::<$to>::into ($expression)),
					$crate::prelude::Result::Err (error) =>
						$crate::prelude::Result::Err (error),
				}
			}
		}
	);
}


macro_rules! impl_try_into_for_outcome {
	( $to : ty, $from : ty ) => (
		impl_try_into_for_outcome! ($to, $from, value, value.try_into ());
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::exports::StdInto0<$crate::exports::Outcome<$to>> for $from {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn into_0 (self) -> ($crate::exports::Outcome<$to>) {
				let $value = self;
				succeed! ($crate::prelude::StdInto::<$to>::into (try! ($expression)));
			}
		}
		impl $crate::exports::StdInto0<$crate::exports::Outcome<$to>> for $crate::exports::Outcome<$from> {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn into_0 (self) -> ($crate::exports::Outcome<$to>) {
				match self {
					$crate::prelude::Result::Ok ($value) =>
						succeed! ($crate::prelude::StdInto::<$to>::into (try! ($expression))),
					$crate::prelude::Result::Err (error) =>
						$crate::prelude::Result::Err (error),
				}
			}
		}
	);
}




macro_rules! impl_from_for_box {
	( $to : ty, $from : ty ) => (
		impl_from_for_box! ($to, $from, value, value);
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $crate::prelude::StdBox<$to> {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn from ($value : $from) -> ($crate::prelude::StdBox<$to>) {
				return $crate::prelude::StdBox::new ($crate::prelude::StdInto::<$to>::into ($expression));
			}
		}
	);
}


macro_rules! impl_try_from_for_box {
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $crate::prelude::StdBox<$to> {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$crate::prelude::StdBox<$to>, $crate::exports::Error>) {
				succeed! ($crate::prelude::StdBox::new ($crate::prelude::StdInto::<$to>::into (try! ($expression))));
			}
		}
	);
}




macro_rules! impl_from_for_type {
	( $to : ident, $from : ty ) => (
		impl_from_for_type! ($to, $from, value, $to ($crate::prelude::StdInto::<$from>::into (value)));
	);
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn from ($value : $from) -> ($to) {
				TODO! ("investigate why the following does not work");
				// return $crate::prelude::StdInto::<$to>::into ($expression);
				return $expression;
			}
		}
		impl_from_for_box! ($to, $from, value, $crate::prelude::StdInto::<$to>::into (value));
		impl_into_for_outcome! ($to, $from, value, $crate::prelude::StdInto::<$to>::into (value));
	);
}


macro_rules! impl_try_from_for_type {
	( $to : ty, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				succeed! ($crate::prelude::StdInto::<$to>::into (try! ($expression)));
			}
		}
		impl_try_from_for_box! ($to, $from, value, $crate::prelude::StdTryInto::<$to>::try_into (value));
		impl_try_into_for_outcome! ($to, $from, value, $crate::prelude::StdTryInto::<$to>::try_into (value));
	);
}




macro_rules! impl_as_ref_for_type {
	( $from : ty ) => (
		impl_as_ref_for_type! ($from, $from, self, self);
	);
	( $to : ty, $from : ty, $self : ident, $expression : expr ) => (
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn as_ref (&$self) -> (&$to) {
				return $expression;
			}
		}
	);
}


macro_rules! impl_as_ref_for_type_wlt {
	( $from : ty, $lifetime : tt ) => (
		impl_as_ref_for_type_wlt! ($from, $from, $lifetime, self, self);
	);
	( $to : ty, $from : ty, $lifetime : tt, $self : ident, $expression : expr ) => (
		impl <$lifetime> $crate::prelude::StdAsRef<$to> for $from {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn as_ref (&$self) -> (&$to) {
				return $expression;
			}
		}
	);
}


macro_rules! impl_try_as_ref_for_type {
	( $to : ty, $from : ty, $self : ident, $expression : expr ) => (
		impl $crate::exports::StdTryAsRef0<$to> for $from {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_as_ref_0 (&$self) -> ($crate::prelude::Result<&$to, $crate::exports::Error>) {
				succeed! (try! ($expression));
			}
		}
	);
}




macro_rules! impl_from_for_enum {
	( $to : ident, $tag : ident, $from : ty ) => (
		impl_from_for_enum! ($to, $tag, $from, value, value);
	);
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn from ($value : $from) -> ($to) {
				return $to::$tag ($crate::prelude::StdInto::<_>::into ($expression));
			}
		}
		impl_from_for_box! ($to, $from, value, $crate::prelude::StdInto::<$to>::into (value));
		impl_into_for_outcome! ($to, $from, value, $crate::prelude::StdInto::<$to>::into (value));
	);
}


macro_rules! impl_try_from_for_enum {
	( $to : ident, $tag : ident, $from : ty, $value : ident, $expression : expr ) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from ($value : $from) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				succeed! ($to::tag ($crate::prelude::StdInto::<_>::into (try! ($expression))));
			}
		}
		impl_try_from_for_box! ($to, $from, value, $crate::prelude::StdTryInto::<$to>::try_into (value));
		impl_try_into_for_outcome! ($to, $from, value, , $crate::prelude::StdTryInto::<$to>::try_into (value));
	);
}




macro_rules! impl_unwrappers_for_box {
	( $to : ty ) => (
		impl_unwrappers_for_box ($to, $to);
	);
	( $from : ty, $to : ty) => (
		impl $crate::prelude::StdFrom<$crate::prelude::StdBox<$from>> for $to {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			#[ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (boxed_local) ) ]
			fn from (value : $crate::prelude::StdBox<$from>) -> ($to) {
				return $crate::prelude::StdInto::<$to>::into (*value);
			}
		}
		/*
		impl $crate::prelude::StdAsRef<$to> for $crate::prelude::StdBox<$from> {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn as_ref (&self) -> (&$to) {
				return $crate::exports::StdAsRef0::<$to>::as_ref_0 (&self);
			}
		}
		*/
	);
}


macro_rules! impl_try_unwrappers_for_box {
	( $to : ty ) => (
		impl_try_unwrappers_for_box ($to, $to);
	);
	( $from : ty, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$crate::prelude::StdBox<$from>> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			#[ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (boxed_local) ) ]
			fn try_from (value : $crate::prelude::StdBox<$from>) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				return $crate::prelude::StdTryInto::<$to>::try_into (*value);
			}
		}
		/*
		impl $crate::exports::StdTryAsRef0<$to> for $crate::prelude::StdBox<$from> {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_as_ref_0 (&self) -> ($crate::prelude::Result<&$to, $crate::exports::Error>) {
				return $crate::exports::StdTryAsRef0::<$to>::try_as_ref_0 (&self);
			}
		}
		*/
	);
}




macro_rules! impl_unwrappers_for_type_wrapper {
	( $from : ty, $to : ty) => (
		impl $crate::prelude::StdFrom<$from> for $to {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn from (value : $from) -> ($to) {
				return $crate::prelude::StdInto::<$to>::into (value.0);
			}
		}
		impl $crate::prelude::StdAsRef<$to> for $from {
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn as_ref (&self) -> (&$to) {
				return &self.0;
			}
		}
		impl_unwrappers_for_box! ($from, $to);
	);
}




macro_rules! impl_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				if let $from::$tag (value) = value {
					succeed! ($crate::prelude::StdInto::<$to>::into (value));
				} else {
					fail! (0x64d097b5);
				}
			}
		}
		/*
		impl $crate::exports::StdTryAsRef0<$to> for $from {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_as_ref_0 (&self) -> ($crate::prelude::Result<&$to, $crate::exports::Error>) {
				if let $from::$tag (ref value) = *self {
					succeed! ($crate::exports::StdAsRef0::<$to>::as_ref_0 (value));
				} else {
					fail! (0x958097f2);
				}
			}
		}
		*/
		impl_try_unwrappers_for_box! ($from, $to);
	);
}




macro_rules! impl_try_unwrappers_for_enum_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				if let $from::$tag (value) = value {
					return $crate::prelude::StdTryInto::<$to>::try_into (value);
				} else {
					fail! (0x3f1bcb88);
				}
			}
		}
		/*
		impl $crate::exports::StdTryAsRef0<$to> for $from {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_as_ref_0 (&self) -> ($crate::prelude::Result<&$to, $crate::exports::Error>) {
				if let $from::$tag (ref value) = *self {
					return $crate::exports::StdTryAsRef0::<$to>::try_as_ref_0 (value);
				} else {
					fail! (0x19768613);
				}
			}
		}
		*/
		impl_try_unwrappers_for_box! ($from, $to);
	);
}




macro_rules! impl_unwrappers_2_for_enum_3_wrapper {
	( $from : ident, $tag : ident, $to : ty) => (
		impl $crate::prelude::StdTryFrom<$from> for $to {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_from (value : $from) -> ($crate::prelude::Result<$to, $crate::exports::Error>) {
				if let $from::$tag (_, value, _) = value {
					succeed! ($crate::prelude::StdInto::<$to>::into (value));
				} else {
					fail! (0x7ac7cc9c);
				}
			}
		}
		impl $crate::exports::StdTryAsRef0<$to> for $from {
			type Error = $crate::exports::Error;
			#[ cfg_attr ( feature = "vonuvoli_inline", inline ) ]
			fn try_as_ref_0 (&self) -> ($crate::prelude::Result<&$to, $crate::exports::Error>) {
				if let $from::$tag (_, ref value, _) = *self {
					succeed! ($crate::exports::StdAsRef0::<$to>::as_ref_0 (value));
				} else {
					fail! (0x1e588e5f);
				}
			}
		}
		impl_try_unwrappers_for_box! ($from, $to);
	);
}




#[ macro_export ]
macro_rules! vec_into {
	( $( $value : expr, )* ) => (
		vec! [ $( $value, )* ] .into_iter () .map (
				|value| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					value.into ()
				})
			.collect::<$crate::prelude::StdVec<_>> ()
	);
}

#[ macro_export ]
macro_rules! vec_map {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		$iterator.map (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::StdVec<_>> ()
	);
}

#[ macro_export ]
macro_rules! vec_map_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		$vector.into_iter () .map (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::StdVec<_>> ()
	);
}

#[ macro_export ]
macro_rules! try_vec_map {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		try! ($iterator.map (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::Result<$crate::prelude::StdVec<_>, _>> ())
	);
}

#[ macro_export ]
macro_rules! try_vec_map_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		try! ($vector.into_iter () .map (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::Result<$crate::prelude::StdVec<_>, _>> ())
	);
}

#[ macro_export ]
macro_rules! vec_fold {
	( $iterator : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		$iterator.fold ($initial,
				|$accumulator, $element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
	);
}

#[ macro_export ]
macro_rules! vec_fold_into {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		$vector.into_iter () .fold ($initial,
				|$accumulator, $element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
	);
}

#[ macro_export ]
macro_rules! try_vec_fold {
	( $iterator : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		try! ($iterator.fold::<$crate::prelude::Result<_, _>, _> ($crate::prelude::Result::Ok ($initial),
				|accumulator, $element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					match accumulator {
						$crate::prelude::Result::Ok ($accumulator) =>
							$expression,
						error =>
							error,
					}
				}))
	);
}

#[ macro_export ]
macro_rules! try_vec_fold_into {
	( $vector : expr, $initial : expr, ($accumulator : pat, $element : pat), $expression : block ) => (
		try! ($vector.into_iter () .fold::<$crate::prelude::Result<_, _>, _> ($crate::prelude::Result::Ok ($initial),
				|accumulator, $element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					match accumulator {
						$crate::prelude::Result::Ok ($accumulator) =>
							$expression,
						error =>
							error,
					}
				}))
	);
}

#[ macro_export ]
macro_rules! vec_filter {
	( $iterator : expr, $element : pat, $expression : expr ) => (
		$iterator.filter (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::StdVec<_>> ()
	);
}

#[ macro_export ]
macro_rules! vec_filter_into {
	( $vector : expr, $element : pat, $expression : expr ) => (
		$vector.into_iter () .filter (
				|$element| {
					#![ cfg_attr ( feature = "vonuvoli_lints_clippy", allow (redundant_closure) ) ]
					$expression
				})
			.collect::<$crate::prelude::StdVec<_>> ()
	);
}




macro_rules! string_concatenate {
	( $( $value : expr ),* ) => (
		{
			let mut buffer = $crate::prelude::StdString::new ();
			$( buffer.push_str ($value); )*
			buffer.into ()
		}
	);
}




#[ macro_export ]
macro_rules! outcome_map {
	( $outcome : ident, $expression : expr ) => (
		outcome_map! ($outcome, $outcome, $expression)
	);
	( $outcome : expr, $value : pat, $expression : expr ) => (
		match $outcome {
			Ok ($value) =>
				Ok ($expression),
			Err (error) =>
				Err (error),
		}
	);
}

#[ macro_export ]
macro_rules! try_outcome_map {
	( $outcome : ident, $expression : expr ) => (
		try_outcome_map! ($outcome, $outcome, $expression)
	);
	( $outcome : expr, $value : pat, $expression : expr ) => (
		match $outcome {
			Ok ($value) =>
				Ok (try! ($expression)),
			Err (error) =>
				Err (error),
		}
	);
}




#[ macro_export ]
macro_rules! option_map {
	( $option : ident, $expression : expr ) => (
		option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some ($expression),
			None =>
				None,
		}
	);
}

#[ macro_export ]
macro_rules! try_option_map {
	( $option : ident, $expression : expr ) => (
		try_option_map! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				Some (try! ($expression)),
			None =>
				None,
		}
	);
}


#[ macro_export ]
macro_rules! option_ref_map {
	( $option : ident, $expression : expr ) => (
		option_ref_map! ($option, $option, $expression)
	);
	( $option : expr, $value : ident, $expression : expr ) => (
		match $option {
			Some (ref $value) =>
				Some ($expression),
			None =>
				None,
		}
	);
}

#[ macro_export ]
macro_rules! try_option_ref_map {
	( $option : ident, $expression : expr ) => (
		try_option_ref_map! ($option, $option, $expression)
	);
	( $option : expr, $value : ident, $expression : expr ) => (
		match $option {
			Some (ref $value) =>
				Some (try! ($expression)),
			None =>
				None,
		}
	);
}




#[ macro_export ]
macro_rules! option_unwrap_or {
	( $option : ident, $expression : expr ) => (
		match $option {
			Some (value) =>
				value,
			None =>
				$expression,
		}
	);
}

#[ macro_export ]
macro_rules! try_option_unwrap_or {
	( $option : ident, $expression : expr ) => (
		match $option {
			Some (value) =>
				value,
			None =>
				try! ($expression),
		}
	);
}




#[ macro_export ]
macro_rules! option_and_then {
	( $option : ident, $expression : expr ) => (
		option_and_then! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				$expression,
			None =>
				None,
		}
	);
}

#[ macro_export ]
macro_rules! try_option_and_then {
	( $option : ident, $expression : expr ) => (
		try_option_and_then! ($option, $option, $expression)
	);
	( $option : expr, $value : pat, $expression : expr ) => (
		match $option {
			Some ($value) =>
				try! ($expression),
			None =>
				None,
		}
	);
}


#[ macro_export ]
macro_rules! option_ref_and_then {
	( $option : ident, $expression : expr ) => (
		option_ref_and_then! ($option, $option, $expression)
	);
	( $option : expr, $value : ident, $expression : expr ) => (
		match $option {
			Some (ref $value) =>
				$expression,
			None =>
				None,
		}
	);
}

#[ macro_export ]
macro_rules! try_option_ref_and_then {
	( $option : ident, $expression : expr ) => (
		try_option_ref_and_then! ($option, $option, $expression)
	);
	( $option : expr, $value : ident, $expression : expr ) => (
		match $option {
			Some (ref $value) =>
				try! ($expression),
			None =>
				None,
		}
	);
}




#[ macro_export ]
macro_rules! try_as_ref {
	( $type : ty, $value : expr ) => (
		try! ($crate::exports::StdTryAsRef0::<$type>::try_as_ref_0 ($value))
	);
}

macro_rules! def_value_try_as_ref {
	( $identifier : ident, $type : ty) => (
		macro_rules! $identifier {
			( $value : expr ) => (
				try_as_ref! ($type, $value)
			);
		}
	);
}


#[ macro_export ]
macro_rules! try_into {
	( $type : ty, $value : expr ) => (
		try! ($crate::prelude::StdTryInto::<$type>::try_into ($value))
	);
}

macro_rules! def_value_try_into {
	( $identifier : ident, $type : ty) => (
		macro_rules! $identifier {
			( $value : expr ) => (
				try_into! ($type, $value)
			);
		}
	);
}


macro_rules! value_type {
	( $type : ident ) => (
		$crate::values::exports::$type
	);
}


def_value_try_as_ref! (try_as_boolean_ref, value_type! (Boolean));
def_value_try_into! (try_into_boolean, value_type! (Boolean));

def_value_try_as_ref! (try_as_number_integer_ref, value_type! (NumberInteger));
def_value_try_into! (try_into_number_integer, value_type! (NumberInteger));

def_value_try_as_ref! (try_as_number_real_ref, value_type! (NumberReal));
def_value_try_into! (try_into_number_real, value_type! (NumberReal));

def_value_try_as_ref! (try_as_character_ref, value_type! (Character));
def_value_try_into! (try_into_character, value_type! (Character));

def_value_try_as_ref! (try_as_symbol_ref, value_type! (Symbol));
def_value_try_into! (try_into_symbol, value_type! (Symbol));

#[ cfg ( feature = "vonuvoli_values_keyword" ) ]
def_value_try_as_ref! (try_as_keyword_ref, value_type! (Keyword));
#[ cfg ( feature = "vonuvoli_values_keyword" ) ]
def_value_try_into! (try_into_keyword, value_type! (Keyword));

#[ cfg ( feature = "vonuvoli_values_unique" ) ]
def_value_try_as_ref! (try_as_unique_ref, value_type! (Unique));
#[ cfg ( feature = "vonuvoli_values_unique" ) ]
def_value_try_into! (try_into_unique, value_type! (Unique));

#[ cfg ( feature = "vonuvoli_values_string" ) ]
def_value_try_as_ref! (try_as_string_immutable_ref, value_type! (StringImmutable));
#[ cfg ( feature = "vonuvoli_values_string" ) ]
def_value_try_into! (try_into_string_immutable, value_type! (StringImmutable));

#[ cfg ( feature = "vonuvoli_values_string" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_as_ref! (try_as_string_mutable_ref, value_type! (StringMutable));
#[ cfg ( feature = "vonuvoli_values_string" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_into! (try_into_string_mutable, value_type! (StringMutable));

#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
def_value_try_as_ref! (try_as_bytes_immutable_ref, value_type! (BytesImmutable));
#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
def_value_try_into! (try_into_bytes_immutable, value_type! (BytesImmutable));

#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_as_ref! (try_as_bytes_mutable_ref, value_type! (BytesMutable));
#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_into! (try_into_bytes_mutable, value_type! (BytesMutable));

#[ cfg ( feature = "vonuvoli_builtins_regex" ) ]
#[ cfg ( feature = "vonuvoli_values_string" ) ]
def_value_try_as_ref! (try_as_string_regex_ref, value_type! (StringRegex));
#[ cfg ( feature = "vonuvoli_builtins_regex" ) ]
#[ cfg ( feature = "vonuvoli_values_string" ) ]
def_value_try_into! (try_into_string_regex, value_type! (StringRegex));

#[ cfg ( feature = "vonuvoli_builtins_regex" ) ]
#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
def_value_try_as_ref! (try_as_bytes_regex_ref, value_type! (BytesRegex));
#[ cfg ( feature = "vonuvoli_builtins_regex" ) ]
#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
def_value_try_into! (try_into_bytes_regex, value_type! (BytesRegex));

def_value_try_as_ref! (try_as_pair_immutable_ref, value_type! (PairImmutable));
def_value_try_into! (try_into_pair_immutable, value_type! (PairImmutable));

#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_as_ref! (try_as_pair_mutable_ref, value_type! (PairMutable));
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_into! (try_into_pair_mutable, value_type! (PairMutable));

#[ cfg ( feature = "vonuvoli_values_array" ) ]
def_value_try_as_ref! (try_as_array_immutable_ref, value_type! (ArrayImmutable));
#[ cfg ( feature = "vonuvoli_values_array" ) ]
def_value_try_into! (try_into_array_immutable, value_type! (ArrayImmutable));

#[ cfg ( feature = "vonuvoli_values_array" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_as_ref! (try_as_array_mutable_ref, value_type! (ArrayMutable));
#[ cfg ( feature = "vonuvoli_values_array" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_into! (try_into_array_mutable, value_type! (ArrayMutable));

#[ cfg ( feature = "vonuvoli_values_values" ) ]
def_value_try_as_ref! (try_as_values_ref, value_type! (Values));
#[ cfg ( feature = "vonuvoli_values_values" ) ]
def_value_try_into! (try_into_values, value_type! (Values));

#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
def_value_try_as_ref! (try_as_record_kind_ref, value_type! (RecordKind));
#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
def_value_try_into! (try_into_record_kind, value_type! (RecordKind));

#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
def_value_try_as_ref! (try_as_record_immutable_ref, value_type! (RecordImmutable));
#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
def_value_try_into! (try_into_record_immutable, value_type! (RecordImmutable));

#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_as_ref! (try_as_record_mutable_ref, value_type! (RecordMutable));
#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
#[ cfg ( feature = "vonuvoli_values_mutable" ) ]
def_value_try_into! (try_into_record_mutable, value_type! (RecordMutable));

#[ cfg ( feature = "vonuvoli_values_error" ) ]
def_value_try_as_ref! (try_as_error_ref, value_type! (Error));
#[ cfg ( feature = "vonuvoli_values_error" ) ]
def_value_try_into! (try_into_error, value_type! (Error));

def_value_try_as_ref! (try_as_procedure_primitive_ref, value_type! (ProcedurePrimitive));
def_value_try_into! (try_into_procedure_primitive, value_type! (ProcedurePrimitive));

#[ cfg ( feature = "vonuvoli_values_extended" ) ]
def_value_try_as_ref! (try_as_procedure_extended_ref, value_type! (ProcedureExtended));
#[ cfg ( feature = "vonuvoli_values_extended" ) ]
def_value_try_into! (try_into_procedure_extended, value_type! (ProcedureExtended));

#[ cfg ( feature = "vonuvoli_values_native" ) ]
def_value_try_as_ref! (try_as_procedure_native_ref, value_type! (ProcedureNative));
#[ cfg ( feature = "vonuvoli_values_native" ) ]
def_value_try_into! (try_into_procedure_native, value_type! (ProcedureNative));

#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_values_lambda" ) ]
def_value_try_as_ref! (try_as_procedure_lambda_ref, value_type! (ProcedureLambda));
#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_values_lambda" ) ]
def_value_try_into! (try_into_procedure_lambda, value_type! (ProcedureLambda));

def_value_try_as_ref! (try_as_syntax_primitive_ref, value_type! (SyntaxPrimitive));
def_value_try_into! (try_into_syntax_primitive, value_type! (SyntaxPrimitive));

#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_extended" ) ]
def_value_try_as_ref! (try_as_syntax_extended_ref, value_type! (SyntaxExtended));
#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_extended" ) ]
def_value_try_into! (try_into_syntax_extended, value_type! (SyntaxExtended));

#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_native" ) ]
def_value_try_as_ref! (try_as_syntax_native_ref, value_type! (SyntaxNative));
#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_native" ) ]
def_value_try_into! (try_into_syntax_native, value_type! (SyntaxNative));

#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_lambda" ) ]
def_value_try_as_ref! (try_as_syntax_lambda_ref, value_type! (SyntaxLambda));
#[ cfg ( feature = "vonuvoli_expressions" ) ]
#[ cfg ( feature = "vonuvoli_compiler" ) ]
#[ cfg ( feature = "vonuvoli_values_lambda" ) ]
def_value_try_into! (try_into_syntax_lambda, value_type! (SyntaxLambda));

#[ cfg ( feature = "vonuvoli_builtins_filesystem" ) ]
def_value_try_as_ref! (try_as_path_ref, value_type! (Path));
#[ cfg ( feature = "vonuvoli_builtins_filesystem" ) ]
def_value_try_into! (try_into_path, value_type! (Path));

#[ cfg ( feature = "vonuvoli_builtins_ports" ) ]
def_value_try_as_ref! (try_as_port_ref, value_type! (Port));
#[ cfg ( feature = "vonuvoli_builtins_ports" ) ]
def_value_try_into! (try_into_port, value_type! (Port));

#[ cfg ( feature = "vonuvoli_builtins_processes" ) ]
def_value_try_as_ref! (try_as_process_ref, value_type! (Process));
#[ cfg ( feature = "vonuvoli_builtins_processes" ) ]
def_value_try_into! (try_into_process, value_type! (Process));

def_value_try_as_ref! (try_as_context_ref, value_type! (Context));
def_value_try_into! (try_into_context, value_type! (Context));

def_value_try_as_ref! (try_as_binding_ref, value_type! (Binding));
def_value_try_into! (try_into_binding, value_type! (Binding));

#[ cfg ( feature = "vonuvoli_builtins_parameters" ) ]
def_value_try_as_ref! (try_as_parameters_ref, value_type! (Parameters));
#[ cfg ( feature = "vonuvoli_builtins_parameters" ) ]
def_value_try_into! (try_into_parameters, value_type! (Parameters));

#[ cfg ( feature = "vonuvoli_builtins_parameters" ) ]
def_value_try_as_ref! (try_as_parameter_ref, value_type! (Parameter));
#[ cfg ( feature = "vonuvoli_builtins_parameters" ) ]
def_value_try_into! (try_into_parameter, value_type! (Parameter));

#[ cfg ( feature = "vonuvoli_builtins_promises" ) ]
def_value_try_as_ref! (try_as_promise_ref, value_type! (Promise));
#[ cfg ( feature = "vonuvoli_builtins_promises" ) ]
def_value_try_into! (try_into_promise, value_type! (Promise));

#[ cfg ( feature = "vonuvoli_values_opaque" ) ]
def_value_try_as_ref! (try_as_opaque_ref, value_type! (Opaque));
#[ cfg ( feature = "vonuvoli_values_opaque" ) ]
def_value_try_into! (try_into_opaque, value_type! (Opaque));




#[ cfg ( feature = "vonuvoli_values_string" ) ]
#[ macro_export ]
macro_rules! try_as_string_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::StringRef::try ($value))
	};
}

#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
#[ macro_export ]
macro_rules! try_as_bytes_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::BytesRef::try ($value))
	};
}

#[ macro_export ]
macro_rules! try_as_pair_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::PairRef::try_ref ($value))
	};
}

#[ cfg ( feature = "vonuvoli_values_array" ) ]
#[ macro_export ]
macro_rules! try_as_array_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::ArrayRef::try ($value))
	};
}

#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
#[ macro_export ]
macro_rules! try_as_record_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::RecordRef::try ($value))
	};
}




#[ cfg ( feature = "vonuvoli_values_string" ) ]
#[ macro_export ]
macro_rules! try_as_string_as_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::StringAsRef::try ($value))
	};
}

#[ cfg ( feature = "vonuvoli_values_bytes" ) ]
#[ macro_export ]
macro_rules! try_as_bytes_as_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::BytesAsRef::try ($value))
	};
}

#[ macro_export ]
macro_rules! try_as_pair_as_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::PairAsRef::try ($value))
	};
}

#[ cfg ( feature = "vonuvoli_values_array" ) ]
#[ macro_export ]
macro_rules! try_as_array_as_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::ArrayAsRef::try ($value))
	};
}

#[ cfg ( feature = "vonuvoli_builtins_records" ) ]
#[ macro_export ]
macro_rules! try_as_record_as_ref {
	( $value : expr ) => {
		try! ($crate::values::exports::RecordAsRef::try ($value))
	};
}




#[ cfg ( feature = "vonuvoli_transcript" ) ]
#[ macro_export ]
macro_rules! def_transcript_root {
	( $identifier : ident ) => (
		#[ allow (non_upper_case_globals) ]
		pub(crate) static $identifier : $crate::exports::TranscriptForModule
				= $crate::exports::TranscriptForModule::new_root (module_path! (), $crate::prelude::Option::None);
	);
}

#[ cfg ( feature = "vonuvoli_transcript" ) ]
#[ macro_export ]
macro_rules! def_transcript {
	( $identifier : ident ) => (
		#[ allow (non_upper_case_globals) ]
		pub(crate) static $identifier : $crate::exports::TranscriptForModule
				= $crate::exports::TranscriptForModule::new (module_path! (), &$crate::TRANSCRIPT);
	);
}


#[ cfg ( feature = "vonuvoli_transcript" ) ]
macro_rules! def_trace_for_level {
	( $identifier : ident, $level : ident ) => (
		#[ macro_export ]
		macro_rules! $identifier {
			( $transcript : expr, $code : expr => $format : tt => $arguments : tt ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					$transcript.trace_format (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							trace_format_args! ($format, $arguments),
							true,
							$crate::prelude::Option::None,
							$crate::prelude::Option::None,
						);
				}
			);
			( $transcript : expr, $code : expr => $format : tt => $arguments : tt, backend = $backend : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					$transcript.trace_format (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							trace_format_args! ($format, $arguments),
							true,
							$crate::prelude::Option::None,
							$crate::prelude::Option::Some ($backend),
						);
				}
			);
			( $transcript : expr, $code : expr => $format : tt => $arguments : tt, error = $error : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					#[ allow (unused_imports) ]
					use $crate::exports::TranscriptError as TraitImportTranscriptError;
					let error = $error;
					let reported = $transcript.trace_format (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							trace_format_args! ($format, $arguments),
							true,
							if error.transcript_was_reported () { $crate::prelude::Option::None } else { $crate::prelude::Option::Some (error) },
							$crate::prelude::Option::None,
						);
					if reported {
						error.transcript_set_reported ();
					}
				}
			);
			( $transcript : expr, $code : expr => $format : tt => $arguments : tt, error = $error : expr, backend = $backend : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					#[ allow (unused_imports) ]
					use $crate::exports::TranscriptError as TraitImportTranscriptError;
					let error = $error;
					let reported = $transcript.trace_format (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							trace_format_args! ($format, $arguments),
							true,
							if error.transcript_was_reported () { $crate::prelude::Option::None } else { $crate::prelude::Option::Some (error) },
							$crate::prelude::Option::Some ($backend),
						);
					if reported {
						error.transcript_set_reported ();
					}
				}
			);
			( $transcript : expr, $code : expr, message = $message : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					$transcript.trace_message (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$message,
							true,
							$crate::prelude::Option::None,
							$crate::prelude::Option::None,
						);
				}
			);
			( $transcript : expr, $code : expr, message = $message : expr, backend = $backend : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					$transcript.trace_message (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$message,
							true,
							$crate::prelude::Option::None,
							$crate::prelude::Option::Some ($backend),
						);
				}
			);
			( $transcript : expr, $code : expr, message = $message : expr, error = $error : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					#[ allow (unused_imports) ]
					use $crate::exports::TranscriptError as TraitImportTranscriptError;
					let error = $error;
					let reported = $transcript.trace_message (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$message,
							true,
							if error.transcript_was_reported () { $crate::prelude::Option::None } else { $crate::prelude::Option::Some (error) },
							$crate::prelude::Option::None,
						);
					if reported {
						error.transcript_set_reported ();
					}
				}
			);
			( $transcript : expr, $code : expr, message = $message : expr, error = $error : expr, backend = $backend : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					#[ allow (unused_imports) ]
					use $crate::exports::TranscriptError as TraitImportTranscriptError;
					let error = $error;
					let reported = $transcript.trace_message (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$message,
							true,
							if error.transcript_was_reported () { $crate::prelude::Option::None } else { $crate::prelude::Option::Some (error) },
							$crate::prelude::Option::Some ($backend),
						);
					if reported {
						error.transcript_set_reported ();
					}
				}
			);
		}
	);
}

#[ cfg ( feature = "vonuvoli_transcript" ) ]
macro_rules! def_tracer_for_level {
	( $identifier : ident, $level : ident ) => (
		#[ macro_export ]
		macro_rules! $identifier {
			( $transcript : expr, $code : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					&$transcript.tracer (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$crate::prelude::Option::None,
						)
				}
			);
			( $transcript : expr, $backend : expr, $code : expr ) => (
				{
					#[ allow (unused_imports) ]
					use $crate::exports::Transcript as TraitImportTranscript;
					&$transcript.tracer (
							$crate::exports::TranscriptLevel::$level,
							$crate::exports::transcript_code_for_source (
									$code,
									$crate::prelude::Option::Some (file! ()),
									$crate::prelude::Option::Some (line! () as usize),
								),
							$crate::prelude::Option::Some ($backend),
						)
				}
			);
		}
	);
}

#[ cfg ( feature = "vonuvoli_transcript" ) ]
#[ macro_export ]
macro_rules! trace_format_args {
	( $format : tt, ( $( $argument : tt )* ) ) => (
		format_args! ( $format, $( $argument )* )
	);
}

#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_critical, Critical);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_error, Error);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_warning, Warning);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_notice, Notice);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_information, Information);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_internal, Internal);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_trace_for_level! (trace_debugging, Debugging);

#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_critical, Critical);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_error, Error);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_warning, Warning);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_notice, Notice);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_information, Information);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_internal, Internal);
#[ cfg ( feature = "vonuvoli_transcript" ) ]
def_tracer_for_level! (tracer_debugging, Debugging);




#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_tests {
	( $identifier : ident, $source : expr ) => (
		#[ test ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier () -> () {
			def_scheme_tests_block! ($identifier, $source);
		}
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_tests_from_file {
	( $( $identifier : ident => $source : expr, )+ ) => (
		$( def_scheme_tests_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_scheme_tests! ($identifier, include_str! ($source));
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_tests_block {
	( $identifier : ident, $source : expr ) => ({
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let source = $source;
		let outcome = execute_tests_main (identifier, source, None, None, None);
		outcome.expect ("d03750c4");
	});
}




#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_benchmarks {
	( $identifier : ident, $source : expr ) => (
		#[ bench ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier (bencher : &mut $crate::externals::test::Bencher) -> () {
			def_scheme_benchmarks_block! ($identifier, $source, bencher);
		}
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_benchmarks_from_file {
	( $( $identifier : ident => $source : expr, )+ ) => (
		$( def_scheme_benchmarks_from_file! ($identifier, $source); )*
	);
	( $identifier : ident, $source : expr ) => (
		def_scheme_benchmarks! ($identifier, include_str! ($source));
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_scheme_benchmarks_block {
	( $identifier : ident, $source : expr, $bencher : expr ) => ({
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let source = $source;
		let outcome = benchmark_tests_main (identifier, source, None, Some ($bencher), None, None, None);
		outcome.expect ("65639c2b");
	});
}




#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_test {
	( $identifier : ident, $expression : expr ) => (
		#[ test ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier () -> () {
			#[ allow (unused_imports) ]
			use $crate::prelude::*;
			#[ allow (unused_imports) ]
			use $crate::exports::*;
			$expression
		}
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_tests {
	( $( $identifier : ident => $expression : block, )+ ) => (
		$( def_test! ($identifier, $expression); )*
	);
}




#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_benchmark {
	( $identifier : ident, { with_values $expression : expr, $( $variable : ident => $initializer : expr, )+ } ) => (
		#[ bench ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier (bencher : &mut $crate::externals::test::Bencher) -> () {
			def_benchmark_block! ($identifier, $expression, ( $( ( $variable, $initializer ) ),* ), bencher);
		}
	);
	( $identifier : ident, { $expression: expr } ) => (
		#[ bench ]
		#[ inline (never) ]
		#[ allow (non_snake_case) ]
		fn $identifier (bencher : &mut $crate::externals::test::Bencher) -> () {
			def_benchmark_block! ($identifier, $expression, bencher);
		}
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_benchmarks {
	( $( $identifier : ident => $token : tt, )+ ) => (
		$( def_benchmark! ($identifier, $token ); )*
	);
}

#[ cfg ( feature = "vonuvoli_tests" ) ]
#[ macro_export ]
macro_rules! def_benchmark_block {
	( $identifier : ident, $expression : expr, ( $( ( $variable : ident, $initializer : expr ) ),+ ), $bencher : expr ) => ({
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let outcome = benchmark_generic_main (identifier,
				|| Ok ( ( $( $initializer, )* ) ),
				|&( $( ref $variable, )* )| {
					#[ warn (unused_must_use) ]
					let _ = $crate::externals::test::black_box ($expression);
					()
				},
				Some ($bencher), None, None, None);
		outcome.expect ("b504b743");
	});
	( $identifier : ident, $expression : expr, $bencher : expr ) => ({
		use $crate::exports::*;
		let identifier = stringify! ($identifier);
		let outcome = benchmark_generic_main (identifier,
				|| Ok (()),
				|&()| {
					#[ warn (unused_must_use) ]
					let _ = $crate::externals::test::black_box ($expression);
					()
				},
				Some ($bencher), None, None, None);
		outcome.expect ("ba9c8ac7");
	});
}




#[ macro_export ]
macro_rules! try_write {
	( $( $token : expr ),+ ) => (
		try_or_fail! (write! ( $( $token, )* ), 0xa51ef801)
	);
}

#[ macro_export ]
macro_rules! try_writeln {
	( $( $token : expr ),+ ) => (
		try_or_fail! (writeln! ( $( $token, )* ), 0xd1c46aa0)
	);
}

