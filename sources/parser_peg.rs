// Generated by rust-peg. Do not edit.
use self::RuleResult::{Failed, Matched};
use super::{builtins::exports as builtins, constants::exports as constants, values::exports as values, values_tests::exports as tests};
use ::std::{f64, prelude::v1::*, str::FromStr, u32, u8, vec, write};
fn escape_default(s : &str) -> String
{
	s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(
	s : &str,
	pos : usize,
) -> (char, usize)
{
	let c = &s[pos ..].chars().next().unwrap();
	let next_pos = pos + c.len_utf8();
	(*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T>
{
	Matched(usize, T),
	Failed,
}
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError
{
	pub line : usize,
	pub column : usize,
	pub offset : usize,
	pub expected : ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError
{
	fn fmt(
		&self,
		fmt : &mut ::std::fmt::Formatter,
	) -> ::std::result::Result<(), ::std::fmt::Error>
	{
		write!(fmt, "error at {}:{}: expected ", self.line, self.column)?;
		if self.expected.len() == 0 {
			write!(fmt, "EOF")?;
		} else if self.expected.len() == 1 {
			write!(fmt, "`{}`", escape_default(self.expected.iter().next().unwrap()))?;
		} else {
			let mut iter = self.expected.iter();
			write!(fmt, "one of `{}`", escape_default(iter.next().unwrap()))?;
			for elem in iter {
				write!(fmt, ", `{}`", escape_default(elem))?;
			}
		}
		Ok(())
	}
}
impl ::std::error::Error for ParseError
{
	fn description(&self) -> &str
	{
		"parse error"
	}
}
fn slice_eq(
	input : &str,
	state : &mut ParseState,
	pos : usize,
	m : &'static str,
) -> RuleResult<()>
{
	#![allow(dead_code)]
	let l = m.len();
	if input.len() >= pos + l && &input.as_bytes()[pos .. pos + l] == m.as_bytes() {
		Matched(pos + l, ())
	} else {
		state.mark_failure(pos, m)
	}
}
fn slice_eq_case_insensitive(
	input : &str,
	state : &mut ParseState,
	pos : usize,
	m : &'static str,
) -> RuleResult<()>
{
	#![allow(dead_code)]
	let mut used = 0usize;
	let mut input_iter = input[pos ..].chars().flat_map(|x| x.to_uppercase());
	for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
		used += m_char_upper.len_utf8();
		let input_char_result = input_iter.next();
		if input_char_result.is_none() || input_char_result.unwrap() != m_char_upper {
			return state.mark_failure(pos, m);
		}
	}
	Matched(pos + used, ())
}
fn any_char(
	input : &str,
	state : &mut ParseState,
	pos : usize,
) -> RuleResult<()>
{
	#![allow(dead_code)]
	if input.len() > pos {
		let (_, next) = char_range_at(input, pos);
		Matched(next, ())
	} else {
		state.mark_failure(pos, "<character>")
	}
}
fn pos_to_line(
	input : &str,
	pos : usize,
) -> (usize, usize)
{
	let before = &input[.. pos];
	let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
	let col = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
	(line, col)
}
impl<'input> ParseState<'input>
{
	fn mark_failure(
		&mut self,
		pos : usize,
		expected : &'static str,
	) -> RuleResult<()>
	{
		if self.suppress_fail == 0 {
			if pos > self.max_err_pos {
				self.max_err_pos = pos;
				self.expected.clear();
			}
			if pos == self.max_err_pos {
				self.expected.insert(expected);
			}
		}
		Failed
	}
}
struct ParseState<'input>
{
	max_err_pos : usize,
	suppress_fail : usize,
	expected : ::std::collections::HashSet<&'static str>,
	_phantom : ::std::marker::PhantomData<&'input ()>,
}
impl<'input> ParseState<'input>
{
	fn new() -> ParseState<'input>
	{
		ParseState {
			max_err_pos : 0,
			suppress_fail : 0,
			expected : ::std::collections::HashSet::new(),
			_phantom : ::std::marker::PhantomData,
		}
	}
}

fn __parse_value<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_abbreviation(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_list(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = __parse_array(__input, __state, __pos);
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = __parse_values(__input, __state, __pos);
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => __parse_atom(__input, __state, __pos),
								}
							},
						}
					},
				}
			},
		}
	}
}

fn __parse_value_sequence<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<Vec<values::Value>>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match __parse_space(__input, __state, __pos) {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					let mut __repeat_value = vec![];
					loop {
						let __pos = __repeat_pos;
						let __pos = if __repeat_value.len() > 0 {
							let __sep_res = match __parse_space(__input, __state, __pos) {
								Matched(__newpos, _) => Matched(__newpos, ()),
								Failed => Matched(__pos, ()),
							};
							match __sep_res {
								Matched(__newpos, _) => __newpos,
								Failed => break,
							}
						} else {
							__pos
						};
						let __step_res = __parse_value(__input, __state, __pos);
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
								__repeat_value.push(__value);
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, __repeat_value)
				};
				match __seq_res {
					Matched(__pos, values) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { values }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_atom<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_boolean(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_number(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = __parse_symbol(__input, __state, __pos);
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = __parse_character(__input, __state, __pos);
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => {
										let __choice_res = __parse_string(__input, __state, __pos);
										match __choice_res {
											Matched(__pos, __value) => Matched(__pos, __value),
											Failed => {
												let __choice_res = __parse_bytes(__input, __state, __pos);
												match __choice_res {
													Matched(__pos, __value) => Matched(__pos, __value),
													Failed => __parse_constant(__input, __state, __pos),
												}
											},
										}
									},
								}
							},
						}
					},
				}
			},
		}
	}
}

fn __parse_list<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_list_empty(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_list_proper(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_list_dotted(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_list_proper<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "(");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = match __parse_space(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __pos = if __repeat_value.len() > 0 {
									let __sep_res = __parse_space(__input, __state, __pos);
									match __sep_res {
										Matched(__newpos, _) => __newpos,
										Failed => break,
									}
								} else {
									__pos
								};
								let __step_res = __parse_value(__input, __state, __pos);
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							Matched(__repeat_pos, __repeat_value)
						};
						match __seq_res {
							Matched(__pos, elements) => {
								let __seq_res = match __parse_space(__input, __state, __pos) {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => {
										let __seq_res = slice_eq(__input, __state, __pos, ")");
										match __seq_res {
											Matched(__pos, _) => Matched(__pos, { builtins::list_collect(elements, Some(true)) }),
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_list_dotted<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "(");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = match __parse_space(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __pos = if __repeat_value.len() > 0 {
									let __sep_res = __parse_space(__input, __state, __pos);
									match __sep_res {
										Matched(__newpos, _) => __newpos,
										Failed => break,
									}
								} else {
									__pos
								};
								let __step_res = __parse_value(__input, __state, __pos);
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							if __repeat_value.len() >= 1 {
								Matched(__repeat_pos, __repeat_value)
							} else {
								Failed
							}
						};
						match __seq_res {
							Matched(__pos, elements) => {
								let __seq_res = __parse_space(__input, __state, __pos);
								match __seq_res {
									Matched(__pos, _) => {
										let __seq_res = slice_eq(__input, __state, __pos, ".");
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = __parse_space(__input, __state, __pos);
												match __seq_res {
													Matched(__pos, _) => {
														let __seq_res = __parse_value(__input, __state, __pos);
														match __seq_res {
															Matched(__pos, last) => {
																let __seq_res = match __parse_space(__input, __state, __pos) {
																	Matched(__newpos, _) => Matched(__newpos, ()),
																	Failed => Matched(__pos, ()),
																};
																match __seq_res {
																	Matched(__pos, _) => {
																		let __seq_res = slice_eq(__input, __state, __pos, ")");
																		match __seq_res {
																			Matched(__pos, _) => Matched(__pos, { builtins::list_collect_dotted(elements, Some(last), Some(true)) }),
																			Failed => Failed,
																		}
																	},
																	Failed => Failed,
																}
															},
															Failed => Failed,
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_list_empty<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = {
				let __seq_res = slice_eq(__input, __state, __pos, "(");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => slice_eq(__input, __state, __pos, ")"),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			};
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#null"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => Matched(__pos, { builtins::list_empty() }),
			Failed => Failed,
		}
	}
}

fn __parse_array<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#array");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "(");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __pos = if __repeat_value.len() > 0 {
											let __sep_res = __parse_space(__input, __state, __pos);
											match __sep_res {
												Matched(__newpos, _) => __newpos,
												Failed => break,
											}
										} else {
											__pos
										};
										let __step_res = __parse_value(__input, __state, __pos);
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									Matched(__repeat_pos, __repeat_value)
								};
								match __seq_res {
									Matched(__pos, elements) => {
										let __seq_res = match __parse_space(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										};
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = slice_eq(__input, __state, __pos, ")");
												match __seq_res {
													Matched(__pos, _) => {
														match {
															#[cfg(feature = "vonuvoli_values_array")]
															let outcome = Ok(values::array_immutable_new(elements).into());
															#[cfg(not(feature = "vonuvoli_values_array"))]
															let outcome = Err("arrays not supported");
															outcome
														} {
															Ok(res) => Matched(__pos, res),
															Err(expected) => {
																__state.mark_failure(__pos, expected);
																Failed
															},
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_values<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#values");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "(");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __pos = if __repeat_value.len() > 0 {
											let __sep_res = __parse_space(__input, __state, __pos);
											match __sep_res {
												Matched(__newpos, _) => __newpos,
												Failed => break,
											}
										} else {
											__pos
										};
										let __step_res = __parse_value(__input, __state, __pos);
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									Matched(__repeat_pos, __repeat_value)
								};
								match __seq_res {
									Matched(__pos, elements) => {
										let __seq_res = match __parse_space(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										};
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = slice_eq(__input, __state, __pos, ")");
												match __seq_res {
													Matched(__pos, _) => {
														match {
															#[cfg(feature = "vonuvoli_values_values")]
															let outcome = Ok(values::values_new_from_vec(elements).into());
															#[cfg(not(feature = "vonuvoli_values_values"))]
															let outcome = Err("values not supported");
															outcome
														} {
															Ok(res) => Matched(__pos, res),
															Err(expected) => {
																__state.mark_failure(__pos, expected);
																Failed
															},
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_abbreviation<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = __parse_abbreviation_prefix(__input, __state, __pos);
		match __seq_res {
			Matched(__pos, abbreviation) => {
				let __seq_res = match __parse_whitespace(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = __parse_value(__input, __state, __pos);
						match __seq_res {
							Matched(__pos, value) => Matched(__pos, { builtins::list_collect(vec![abbreviation, value], Some(true)) }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_abbreviation_prefix<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __choice_res = slice_eq(__input, __state, __pos, "'");
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = slice_eq(__input, __state, __pos, "`");
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = slice_eq(__input, __state, __pos, ",@");
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => slice_eq(__input, __state, __pos, ","),
								}
							},
						}
					},
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) => {
				match {
					match value {
						"'" => Ok(values::symbol_clone_str("quote").into()),
						"`" => Ok(values::symbol_clone_str("quasiquote").into()),
						"," => Ok(values::symbol_clone_str("unquote").into()),
						",@" => Ok(values::symbol_clone_str("unquote-splicing").into()),
						_ => Err("a2007ac4"),
					}
				} {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_boolean<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_boolean_true(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => __parse_boolean_false(__input, __state, __pos),
		}
	}
}

fn __parse_boolean_true<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = {
			let __seq_res = slice_eq(__input, __state, __pos, "#true");
			match __seq_res {
				Matched(__pos, _) => Matched(__pos, { constants::TRUE.into() }),
				Failed => Failed,
			}
		};
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __seq_res = slice_eq(__input, __state, __pos, "#t");
				match __seq_res {
					Matched(__pos, _) => Matched(__pos, { constants::TRUE.into() }),
					Failed => Failed,
				}
			},
		}
	}
}

fn __parse_boolean_false<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = {
			let __seq_res = slice_eq(__input, __state, __pos, "#false");
			match __seq_res {
				Matched(__pos, _) => Matched(__pos, { constants::FALSE.into() }),
				Failed => Failed,
			}
		};
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __seq_res = slice_eq(__input, __state, __pos, "#f");
				match __seq_res {
					Matched(__pos, _) => Matched(__pos, { constants::FALSE.into() }),
					Failed => Failed,
				}
			},
		}
	}
}

fn __parse_number<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = __parse_number_real(__input, __state, __pos);
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => __parse_number_integer(__input, __state, __pos),
			}
		};
		match __seq_res {
			Matched(__pos, value) => {
				let __seq_res = {
					__state.suppress_fail += 1;
					let __assert_res = __parse_symbol_character_glyph(__input, __state, __pos);
					__state.suppress_fail -= 1;
					match __assert_res {
						Failed => Matched(__pos, ()),
						Matched(..) => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, _) => Matched(__pos, { value.into() }),
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_sign<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = slice_eq(__input, __state, __pos, "+");
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => slice_eq(__input, __state, __pos, "-"),
		}
	}
}

fn __parse_number_integer<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_number_integer_2(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_number_integer_8(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = __parse_number_integer_10(__input, __state, __pos);
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => __parse_number_integer_16(__input, __state, __pos),
						}
					},
				}
			},
		}
	}
}

fn __parse_number_integer_2<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#b");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#B"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __seq_res = match __parse_number_sign(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let mut __repeat_pos = __pos;
								let mut __repeat_value = vec![];
								loop {
									let __pos = __repeat_pos;
									let __step_res = if __input.len() > __pos {
										let (__ch, __next) = char_range_at(__input, __pos);
										match __ch {
											'0' ..= '1' => Matched(__next, ()),
											_ => __state.mark_failure(__pos, "[0-1]"),
										}
									} else {
										__state.mark_failure(__pos, "[0-1]")
									};
									match __step_res {
										Matched(__newpos, __value) => {
											__repeat_pos = __newpos;
											__repeat_value.push(__value);
										},
										Failed => {
											break;
										},
									}
								}
								if __repeat_value.len() >= 1 {
									Matched(__repeat_pos, ())
								} else {
									Failed
								}
							},
							Failed => Failed,
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) =>
						match { i64::from_str_radix(value, 2).map(|value| values::number_i64(value).into()).map_err(|_| "invalid real syntax") } {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_integer_8<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#o");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#O"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __seq_res = match __parse_number_sign(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let mut __repeat_pos = __pos;
								let mut __repeat_value = vec![];
								loop {
									let __pos = __repeat_pos;
									let __step_res = if __input.len() > __pos {
										let (__ch, __next) = char_range_at(__input, __pos);
										match __ch {
											'0' ..= '7' => Matched(__next, ()),
											_ => __state.mark_failure(__pos, "[0-7]"),
										}
									} else {
										__state.mark_failure(__pos, "[0-7]")
									};
									match __step_res {
										Matched(__newpos, __value) => {
											__repeat_pos = __newpos;
											__repeat_value.push(__value);
										},
										Failed => {
											break;
										},
									}
								}
								if __repeat_value.len() >= 1 {
									Matched(__repeat_pos, ())
								} else {
									Failed
								}
							},
							Failed => Failed,
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) =>
						match { i64::from_str_radix(value, 8).map(|value| values::number_i64(value).into()).map_err(|_| "invalid real syntax") } {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_integer_10<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match {
			let __choice_res = slice_eq(__input, __state, __pos, "#d");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#D"),
			}
		} {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __seq_res = match __parse_number_sign(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let mut __repeat_pos = __pos;
								let mut __repeat_value = vec![];
								loop {
									let __pos = __repeat_pos;
									let __step_res = if __input.len() > __pos {
										let (__ch, __next) = char_range_at(__input, __pos);
										match __ch {
											'0' ..= '9' => Matched(__next, ()),
											_ => __state.mark_failure(__pos, "[0-9]"),
										}
									} else {
										__state.mark_failure(__pos, "[0-9]")
									};
									match __step_res {
										Matched(__newpos, __value) => {
											__repeat_pos = __newpos;
											__repeat_value.push(__value);
										},
										Failed => {
											break;
										},
									}
								}
								if __repeat_value.len() >= 1 {
									Matched(__repeat_pos, ())
								} else {
									Failed
								}
							},
							Failed => Failed,
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) =>
						match { i64::from_str_radix(value, 10).map(|value| values::number_i64(value).into()).map_err(|_| "invalid real syntax") } {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_integer_16<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#x");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#X"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __seq_res = match __parse_number_sign(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let mut __repeat_pos = __pos;
								let mut __repeat_value = vec![];
								loop {
									let __pos = __repeat_pos;
									let __step_res = if __input.len() > __pos {
										let (__ch, __next) = char_range_at(__input, __pos);
										match __ch {
											'0' ..= '9' | 'a' ..= 'f' | 'A' ..= 'F' => Matched(__next, ()),
											_ => __state.mark_failure(__pos, "[0-9a-fA-F]"),
										}
									} else {
										__state.mark_failure(__pos, "[0-9a-fA-F]")
									};
									match __step_res {
										Matched(__newpos, __value) => {
											__repeat_pos = __newpos;
											__repeat_value.push(__value);
										},
										Failed => {
											break;
										},
									}
								}
								if __repeat_value.len() >= 1 {
									Matched(__repeat_pos, ())
								} else {
									Failed
								}
							},
							Failed => Failed,
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) =>
						match { i64::from_str_radix(value, 16).map(|value| values::number_i64(value).into()).map_err(|_| "invalid real syntax") } {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_number_real_variant_1(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_number_real_variant_2(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = __parse_number_real_variant_3(__input, __state, __pos);
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = __parse_number_real_variant_4(__input, __state, __pos);
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => {
										let __choice_res = __parse_number_real_inf(__input, __state, __pos);
										match __choice_res {
											Matched(__pos, __value) => Matched(__pos, __value),
											Failed => {
												let __choice_res = __parse_number_real_nan(__input, __state, __pos);
												match __choice_res {
													Matched(__pos, __value) => Matched(__pos, __value),
													Failed => __parse_number_real_epsilon(__input, __state, __pos),
												}
											},
										}
									},
								}
							},
						}
					},
				}
			},
		}
	}
}

fn __parse_number_real_variant_1<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __seq_res = match __parse_number_sign(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __step_res = if __input.len() > __pos {
									let (__ch, __next) = char_range_at(__input, __pos);
									match __ch {
										'0' ..= '9' => Matched(__next, ()),
										_ => __state.mark_failure(__pos, "[0-9]"),
									}
								} else {
									__state.mark_failure(__pos, "[0-9]")
								};
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							if __repeat_value.len() >= 1 {
								Matched(__repeat_pos, ())
							} else {
								Failed
							}
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = slice_eq(__input, __state, __pos, ".");
								match __seq_res {
									Matched(__pos, _) => {
										let __seq_res = {
											let mut __repeat_pos = __pos;
											let mut __repeat_value = vec![];
											loop {
												let __pos = __repeat_pos;
												let __step_res = if __input.len() > __pos {
													let (__ch, __next) = char_range_at(__input, __pos);
													match __ch {
														'0' ..= '9' => Matched(__next, ()),
														_ => __state.mark_failure(__pos, "[0-9]"),
													}
												} else {
													__state.mark_failure(__pos, "[0-9]")
												};
												match __step_res {
													Matched(__newpos, __value) => {
														__repeat_pos = __newpos;
														__repeat_value.push(__value);
													},
													Failed => {
														break;
													},
												}
											}
											if __repeat_value.len() >= 1 {
												Matched(__repeat_pos, ())
											} else {
												Failed
											}
										};
										match __seq_res {
											Matched(__pos, _) =>
												match __parse_number_real_exponent(__input, __state, __pos) {
													Matched(__newpos, _) => Matched(__newpos, ()),
													Failed => Matched(__pos, ()),
												},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { f64::from_str(value).map(|value| values::number_f64(value).into()).map_err(|_| "invalid real syntax") } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_variant_2<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __seq_res = match __parse_number_sign(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __step_res = if __input.len() > __pos {
									let (__ch, __next) = char_range_at(__input, __pos);
									match __ch {
										'0' ..= '9' => Matched(__next, ()),
										_ => __state.mark_failure(__pos, "[0-9]"),
									}
								} else {
									__state.mark_failure(__pos, "[0-9]")
								};
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							if __repeat_value.len() >= 1 {
								Matched(__repeat_pos, ())
							} else {
								Failed
							}
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = slice_eq(__input, __state, __pos, ".");
								match __seq_res {
									Matched(__pos, _) =>
										match __parse_number_real_exponent(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { f64::from_str(value).map(|value| values::number_f64(value).into()).map_err(|_| "invalid real syntax") } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_variant_3<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __seq_res = match __parse_number_sign(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = slice_eq(__input, __state, __pos, ".");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __step_res = if __input.len() > __pos {
											let (__ch, __next) = char_range_at(__input, __pos);
											match __ch {
												'0' ..= '9' => Matched(__next, ()),
												_ => __state.mark_failure(__pos, "[0-9]"),
											}
										} else {
											__state.mark_failure(__pos, "[0-9]")
										};
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									if __repeat_value.len() >= 1 {
										Matched(__repeat_pos, ())
									} else {
										Failed
									}
								};
								match __seq_res {
									Matched(__pos, _) =>
										match __parse_number_real_exponent(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { f64::from_str(value).map(|value| values::number_f64(value).into()).map_err(|_| "invalid real syntax") } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_variant_4<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __seq_res = match __parse_number_sign(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __step_res = if __input.len() > __pos {
									let (__ch, __next) = char_range_at(__input, __pos);
									match __ch {
										'0' ..= '9' => Matched(__next, ()),
										_ => __state.mark_failure(__pos, "[0-9]"),
									}
								} else {
									__state.mark_failure(__pos, "[0-9]")
								};
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							if __repeat_value.len() >= 1 {
								Matched(__repeat_pos, ())
							} else {
								Failed
							}
						};
						match __seq_res {
							Matched(__pos, _) => __parse_number_real_exponent(__input, __state, __pos),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { f64::from_str(value).map(|value| values::number_f64(value).into()).map_err(|_| "invalid real syntax") } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_inf<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_number_real_inf_positive(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => __parse_number_real_inf_negative(__input, __state, __pos),
		}
	}
}

fn __parse_number_real_inf_positive<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match {
			let __seq_res = {
				__state.suppress_fail += 1;
				let __assert_res = slice_eq(__input, __state, __pos, "+");
				__state.suppress_fail -= 1;
				match __assert_res {
					Matched(_, __value) => Matched(__pos, __value),
					Failed => Failed,
				}
			};
			match __seq_res {
				Matched(__pos, _) => __parse_number_sign(__input, __state, __pos),
				Failed => Failed,
			}
		} {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "inf");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { constants::INF_POSITIVE.into() }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_inf_negative<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			__state.suppress_fail += 1;
			let __assert_res = slice_eq(__input, __state, __pos, "-");
			__state.suppress_fail -= 1;
			match __assert_res {
				Matched(_, __value) => Matched(__pos, __value),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = __parse_number_sign(__input, __state, __pos);
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = slice_eq(__input, __state, __pos, "inf");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => Matched(__pos, { constants::INF_NEGATIVE.into() }),
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_nan<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_number_real_nan_positive(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => __parse_number_real_nan_negative(__input, __state, __pos),
		}
	}
}

fn __parse_number_real_nan_positive<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match {
			let __seq_res = {
				__state.suppress_fail += 1;
				let __assert_res = slice_eq(__input, __state, __pos, "+");
				__state.suppress_fail -= 1;
				match __assert_res {
					Matched(_, __value) => Matched(__pos, __value),
					Failed => Failed,
				}
			};
			match __seq_res {
				Matched(__pos, _) => __parse_number_sign(__input, __state, __pos),
				Failed => Failed,
			}
		} {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "nan");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { constants::NAN_POSITIVE.into() }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_nan_negative<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			__state.suppress_fail += 1;
			let __assert_res = slice_eq(__input, __state, __pos, "-");
			__state.suppress_fail -= 1;
			match __assert_res {
				Matched(_, __value) => Matched(__pos, __value),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = __parse_number_sign(__input, __state, __pos);
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = slice_eq(__input, __state, __pos, "nan");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => Matched(__pos, { constants::NAN_NEGATIVE.into() }),
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_epsilon<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_number_real_epsilon_positive(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => __parse_number_real_epsilon_negative(__input, __state, __pos),
		}
	}
}

fn __parse_number_real_epsilon_positive<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match {
			let __seq_res = {
				__state.suppress_fail += 1;
				let __assert_res = slice_eq(__input, __state, __pos, "+");
				__state.suppress_fail -= 1;
				match __assert_res {
					Matched(_, __value) => Matched(__pos, __value),
					Failed => Failed,
				}
			};
			match __seq_res {
				Matched(__pos, _) => __parse_number_sign(__input, __state, __pos),
				Failed => Failed,
			}
		} {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "epsilon");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { constants::EPSILON_POSITIVE.into() }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_epsilon_negative<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			__state.suppress_fail += 1;
			let __assert_res = slice_eq(__input, __state, __pos, "-");
			__state.suppress_fail -= 1;
			match __assert_res {
				Matched(_, __value) => Matched(__pos, __value),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = __parse_number_sign(__input, __state, __pos);
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = slice_eq(__input, __state, __pos, "epsilon");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => Matched(__pos, { constants::EPSILON_NEGATIVE.into() }),
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_number_real_exponent<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "e");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "E"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = match __parse_number_sign(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let mut __repeat_pos = __pos;
						let mut __repeat_value = vec![];
						loop {
							let __pos = __repeat_pos;
							let __step_res = if __input.len() > __pos {
								let (__ch, __next) = char_range_at(__input, __pos);
								match __ch {
									'0' ..= '9' => Matched(__next, ()),
									_ => __state.mark_failure(__pos, "[0-9]"),
								}
							} else {
								__state.mark_failure(__pos, "[0-9]")
							};
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
									__repeat_value.push(__value);
								},
								Failed => {
									break;
								},
							}
						}
						if __repeat_value.len() >= 1 {
							Matched(__repeat_pos, ())
						} else {
							Failed
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_character<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_character_glyph(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_character_escaped(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_character_named(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_character_glyph<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "#\\");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match any_char(__input, __state, __pos) {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, glyph) => {
						let __seq_res = {
							__state.suppress_fail += 1;
							let __assert_res = match __parse_atom(__input, __state, __pos) {
								Matched(pos, _) => Matched(pos, ()),
								Failed => Failed,
							};
							__state.suppress_fail -= 1;
							match __assert_res {
								Failed => Matched(__pos, ()),
								Matched(..) => Failed,
							}
						};
						match __seq_res {
							Matched(__pos, _) => {
								match {
									#[cfg(feature = "vonuvoli_values_string")]
									let outcome = Ok(values::character(glyph.chars().next().expect("36da249a")).into());
									#[cfg(not(feature = "vonuvoli_values_string"))]
									let outcome = Err("strings are not supported");
									outcome
								} {
									Ok(res) => Matched(__pos, res),
									Err(expected) => {
										__state.mark_failure(__pos, expected);
										Failed
									},
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_character_escaped<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#\\x");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "#\\X"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let mut __repeat_pos = __pos;
						let mut __repeat_value = vec![];
						loop {
							let __pos = __repeat_pos;
							let __step_res = if __input.len() > __pos {
								let (__ch, __next) = char_range_at(__input, __pos);
								match __ch {
									'0' ..= '9' | 'a' ..= 'f' | 'A' ..= 'F' => Matched(__next, ()),
									_ => __state.mark_failure(__pos, "[0-9a-fA-F]"),
								}
							} else {
								__state.mark_failure(__pos, "[0-9a-fA-F]")
							};
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
									__repeat_value.push(__value);
								},
								Failed => {
									break;
								},
							}
						}
						if __repeat_value.len() >= 1 {
							Matched(__repeat_pos, ())
						} else {
							Failed
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) => {
						match {
							#[cfg(feature = "vonuvoli_values_string")]
							let outcome = u32::from_str_radix(value, 16).map_err(|_| "invalid character syntax").and_then(|value| char::from_u32(value).ok_or("invalid character value")).map(|character| values::character(character).into());
							#[cfg(not(feature = "vonuvoli_values_string"))]
							let outcome = Err("strings are not supported");
							outcome
						} {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_character_named<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "#\\");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __choice_res = slice_eq(__input, __state, __pos, "alarm");
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = slice_eq(__input, __state, __pos, "backspace");
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => {
										let __choice_res = slice_eq(__input, __state, __pos, "delete");
										match __choice_res {
											Matched(__pos, __value) => Matched(__pos, __value),
											Failed => {
												let __choice_res = slice_eq(__input, __state, __pos, "escape");
												match __choice_res {
													Matched(__pos, __value) => Matched(__pos, __value),
													Failed => {
														let __choice_res = slice_eq(__input, __state, __pos, "newline");
														match __choice_res {
															Matched(__pos, __value) => Matched(__pos, __value),
															Failed => {
																let __choice_res = slice_eq(__input, __state, __pos, "null");
																match __choice_res {
																	Matched(__pos, __value) => Matched(__pos, __value),
																	Failed => {
																		let __choice_res = slice_eq(__input, __state, __pos, "return");
																		match __choice_res {
																			Matched(__pos, __value) => Matched(__pos, __value),
																			Failed => {
																				let __choice_res = slice_eq(__input, __state, __pos, "space");
																				match __choice_res {
																					Matched(__pos, __value) => Matched(__pos, __value),
																					Failed => slice_eq(__input, __state, __pos, "tab"),
																				}
																			},
																		}
																	},
																}
															},
														}
													},
												}
											},
										}
									},
								}
							},
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) => {
						match {
							#[cfg(feature = "vonuvoli_values_string")]
							let outcome = match value {
								"alarm" => Ok(values::character(7 as char).into()),
								"backspace" => Ok(values::character(8 as char).into()),
								"delete" => Ok(values::character(127 as char).into()),
								"escape" => Ok(values::character(27 as char).into()),
								"newline" => Ok(values::character(10 as char).into()),
								"null" => Ok(values::character(0 as char).into()),
								"return" => Ok(values::character(13 as char).into()),
								"space" => Ok(values::character(32 as char).into()),
								"tab" => Ok(values::character(9 as char).into()),
								_ => Err("fcfc68be"),
							};
							#[cfg(not(feature = "vonuvoli_values_string"))]
							let outcome = Err("strings are not supported");
							outcome
						} {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_symbol<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_symbol_multiple_characters(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_symbol_single_character(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_symbol_string(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_symbol_single_character<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			__state.suppress_fail += 1;
			let __assert_res = slice_eq(__input, __state, __pos, ".");
			__state.suppress_fail -= 1;
			match __assert_res {
				Failed => Matched(__pos, ()),
				Matched(..) => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match __parse_symbol_character_glyph(__input, __state, __pos) {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) => Matched(__pos, { values::symbol_clone_str(value).into() }),
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_symbol_multiple_characters<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let __seq_res = __parse_symbol_character_glyph(__input, __state, __pos);
				match __seq_res {
					Matched(__pos, _) => {
						let mut __repeat_pos = __pos;
						let mut __repeat_value = vec![];
						loop {
							let __pos = __repeat_pos;
							let __step_res = __parse_symbol_character_glyph(__input, __state, __pos);
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
									__repeat_value.push(__value);
								},
								Failed => {
									break;
								},
							}
						}
						if __repeat_value.len() >= 1 {
							Matched(__repeat_pos, ())
						} else {
							Failed
						}
					},
					Failed => Failed,
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) => Matched(__pos, { values::symbol_clone_str(value).into() }),
			Failed => Failed,
		}
	}
}

fn __parse_symbol_character_glyph<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = if __input.len() > __pos {
			let (__ch, __next) = char_range_at(__input, __pos);
			match __ch {
				'a' ..= 'z' | 'A' ..= 'Z' => Matched(__next, ()),
				_ => __state.mark_failure(__pos, "[a-zA-Z]"),
			}
		} else {
			__state.mark_failure(__pos, "[a-zA-Z]")
		};
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = if __input.len() > __pos {
					let (__ch, __next) = char_range_at(__input, __pos);
					match __ch {
						'!' | '$' | '%' | '&' | '*' | '/' | ':' | '<' | '=' | '>' | '?' | '^' | '_' | '~' => Matched(__next, ()),
						_ => __state.mark_failure(__pos, "[!$%&*/:<=>?^_~]"),
					}
				} else {
					__state.mark_failure(__pos, "[!$%&*/:<=>?^_~]")
				};
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = if __input.len() > __pos {
							let (__ch, __next) = char_range_at(__input, __pos);
							match __ch {
								'0' ..= '9' => Matched(__next, ()),
								_ => __state.mark_failure(__pos, "[0-9]"),
							}
						} else {
							__state.mark_failure(__pos, "[0-9]")
						};
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed =>
								if __input.len() > __pos {
									let (__ch, __next) = char_range_at(__input, __pos);
									match __ch {
										'@' | '.' | '+' | '-' => Matched(__next, ()),
										_ => __state.mark_failure(__pos, "[@.+-]"),
									}
								} else {
									__state.mark_failure(__pos, "[@.+-]")
								},
						}
					},
				}
			},
		}
	}
}

fn __parse_symbol_string<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "|");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					let mut __repeat_value = vec![];
					loop {
						let __pos = __repeat_pos;
						let __step_res = __parse_symbol_string_character(__input, __state, __pos);
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
								__repeat_value.push(__value);
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, __repeat_value)
				};
				match __seq_res {
					Matched(__pos, elements) => {
						let __seq_res = slice_eq(__input, __state, __pos, "|");
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { values::symbol_clone_characters(elements.as_slice()).into() }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_symbol_string_character<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_symbol_string_character_glyph(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_string_character_escaped(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_string_character_named(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_symbol_string_character_glyph<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match if __input.len() > __pos {
				let (__ch, __next) = char_range_at(__input, __pos);
				match __ch {
					'|' | '\\' => __state.mark_failure(__pos, "[^|\\]"),
					_ => Matched(__next, ()),
				}
			} else {
				__state.mark_failure(__pos, "[^|\\]")
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, glyph) => Matched(__pos, { glyph.chars().next().expect("56031166") }),
			Failed => Failed,
		}
	}
}

fn __parse_string<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_string_quoted(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_string_array(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_string_document(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_string_quoted<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "\"");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					let mut __repeat_value = vec![];
					loop {
						let __pos = __repeat_pos;
						let __step_res = __parse_string_character(__input, __state, __pos);
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
								__repeat_value.push(__value);
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, __repeat_value)
				};
				match __seq_res {
					Matched(__pos, elements) => {
						let __seq_res = slice_eq(__input, __state, __pos, "\"");
						match __seq_res {
							Matched(__pos, _) => {
								match {
									#[cfg(feature = "vonuvoli_values_string")]
									let outcome = Ok(values::string_immutable_clone_characters(elements.as_slice()).into());
									#[cfg(not(feature = "vonuvoli_values_string"))]
									let outcome = Err("strings are not supported");
									outcome
								} {
									Ok(res) => Matched(__pos, res),
									Err(expected) => {
										__state.mark_failure(__pos, expected);
										Failed
									},
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_string_character<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_string_character_glyph(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = __parse_string_character_escaped(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_string_character_named(__input, __state, __pos),
				}
			},
		}
	}
}

fn __parse_string_character_glyph<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match if __input.len() > __pos {
				let (__ch, __next) = char_range_at(__input, __pos);
				match __ch {
					'"' | '\\' => __state.mark_failure(__pos, "[^\"\\]"),
					_ => Matched(__next, ()),
				}
			} else {
				__state.mark_failure(__pos, "[^\"\\]")
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, glyph) => Matched(__pos, { glyph.chars().next().expect("61d18567") }),
			Failed => Failed,
		}
	}
}

fn __parse_string_character_escaped<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "\\x");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => slice_eq(__input, __state, __pos, "\\X"),
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let mut __repeat_pos = __pos;
						let mut __repeat_value = vec![];
						loop {
							let __pos = __repeat_pos;
							let __step_res = if __input.len() > __pos {
								let (__ch, __next) = char_range_at(__input, __pos);
								match __ch {
									'0' ..= '9' | 'a' ..= 'f' | 'A' ..= 'F' => Matched(__next, ()),
									_ => __state.mark_failure(__pos, "[0-9a-fA-F]"),
								}
							} else {
								__state.mark_failure(__pos, "[0-9a-fA-F]")
							};
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
									__repeat_value.push(__value);
								},
								Failed => {
									break;
								},
							}
						}
						if __repeat_value.len() >= 1 {
							Matched(__repeat_pos, ())
						} else {
							Failed
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) => {
						let __seq_res = slice_eq(__input, __state, __pos, ";");
						match __seq_res {
							Matched(__pos, _) =>
								match { u32::from_str_radix(value, 16).map_err(|_| "invalid character syntax").and_then(|value| char::from_u32(value).ok_or("invalid character value")) } {
									Ok(res) => Matched(__pos, res),
									Err(expected) => {
										__state.mark_failure(__pos, expected);
										Failed
									},
								},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_string_character_named<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "\\");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let str_start = __pos;
					match {
						let __choice_res = slice_eq(__input, __state, __pos, "a");
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __choice_res = slice_eq(__input, __state, __pos, "b");
								match __choice_res {
									Matched(__pos, __value) => Matched(__pos, __value),
									Failed => {
										let __choice_res = slice_eq(__input, __state, __pos, "t");
										match __choice_res {
											Matched(__pos, __value) => Matched(__pos, __value),
											Failed => {
												let __choice_res = slice_eq(__input, __state, __pos, "n");
												match __choice_res {
													Matched(__pos, __value) => Matched(__pos, __value),
													Failed => {
														let __choice_res = slice_eq(__input, __state, __pos, "r");
														match __choice_res {
															Matched(__pos, __value) => Matched(__pos, __value),
															Failed => {
																let __choice_res = slice_eq(__input, __state, __pos, "\\");
																match __choice_res {
																	Matched(__pos, __value) => Matched(__pos, __value),
																	Failed => {
																		let __choice_res = slice_eq(__input, __state, __pos, "\"");
																		match __choice_res {
																			Matched(__pos, __value) => Matched(__pos, __value),
																			Failed => slice_eq(__input, __state, __pos, "|"),
																		}
																	},
																}
															},
														}
													},
												}
											},
										}
									},
								}
							},
						}
					} {
						Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
						Failed => Failed,
					}
				};
				match __seq_res {
					Matched(__pos, value) => {
						match {
							match value {
								"a" => Ok(7 as char),
								"b" => Ok(8 as char),
								"n" => Ok(10 as char),
								"r" => Ok(13 as char),
								"t" => Ok(9 as char),
								"\\" => Ok('\\'),
								"\"" => Ok('"'),
								"|" => Ok('|'),
								_ => Err("285687fe"),
							}
						} {
							Ok(res) => Matched(__pos, res),
							Err(expected) => {
								__state.mark_failure(__pos, expected);
								Failed
							},
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_string_array<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "#string");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "(");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __pos = if __repeat_value.len() > 0 {
											let __sep_res = __parse_space(__input, __state, __pos);
											match __sep_res {
												Matched(__newpos, _) => __newpos,
												Failed => break,
											}
										} else {
											__pos
										};
										let __step_res = __parse_string_array_character(__input, __state, __pos);
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									Matched(__repeat_pos, __repeat_value)
								};
								match __seq_res {
									Matched(__pos, elements) => {
										let __seq_res = match __parse_space(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										};
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = slice_eq(__input, __state, __pos, ")");
												match __seq_res {
													Matched(__pos, _) => {
														match {
															#[cfg(feature = "vonuvoli_values_string")]
															let outcome = Ok(values::string_immutable_clone_characters(elements.as_slice()).into());
															#[cfg(not(feature = "vonuvoli_values_string"))]
															let outcome = Err("strings are not supported");
															outcome
														} {
															Ok(res) => Matched(__pos, res),
															Err(expected) => {
																__state.mark_failure(__pos, expected);
																Failed
															},
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_string_array_character<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<char>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let mut __repeat_pos = __pos;
				let mut __repeat_value = vec![];
				loop {
					let __pos = __repeat_pos;
					let __step_res = if __input.len() > __pos {
						let (__ch, __next) = char_range_at(__input, __pos);
						match __ch {
							'0' ..= '9' => Matched(__next, ()),
							_ => __state.mark_failure(__pos, "[0-9]"),
						}
					} else {
						__state.mark_failure(__pos, "[0-9]")
					};
					match __step_res {
						Matched(__newpos, __value) => {
							__repeat_pos = __newpos;
							__repeat_value.push(__value);
						},
						Failed => {
							break;
						},
					}
				}
				if __repeat_value.len() >= 1 {
					Matched(__repeat_pos, ())
				} else {
					Failed
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { u32::from_str(value).map_err(|_| "invalid character syntax").and_then(|value| char::from_u32(value).ok_or("invalid character value")) } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_string_document<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "#<<<");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					loop {
						let __pos = __repeat_pos;
						let __step_res = if __input.len() > __pos {
							let (__ch, __next) = char_range_at(__input, __pos);
							match __ch {
								' ' | '\t' => Matched(__next, ()),
								_ => __state.mark_failure(__pos, "[ \t]"),
							}
						} else {
							__state.mark_failure(__pos, "[ \t]")
						};
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, ())
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = if __input.len() > __pos {
							let (__ch, __next) = char_range_at(__input, __pos);
							match __ch {
								'\n' => Matched(__next, ()),
								_ => __state.mark_failure(__pos, "[\n]"),
							}
						} else {
							__state.mark_failure(__pos, "[\n]")
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __pos = if __repeat_value.len() > 0 {
											let __sep_res = if __input.len() > __pos {
												let (__ch, __next) = char_range_at(__input, __pos);
												match __ch {
													'\n' => Matched(__next, ()),
													_ => __state.mark_failure(__pos, "[\n]"),
												}
											} else {
												__state.mark_failure(__pos, "[\n]")
											};
											match __sep_res {
												Matched(__newpos, _) => __newpos,
												Failed => break,
											}
										} else {
											__pos
										};
										let __step_res = {
											let str_start = __pos;
											match {
												let __seq_res = {
													let mut __repeat_pos = __pos;
													loop {
														let __pos = __repeat_pos;
														let __step_res = if __input.len() > __pos {
															let (__ch, __next) = char_range_at(__input, __pos);
															match __ch {
																' ' | '\t' => Matched(__next, ()),
																_ => __state.mark_failure(__pos, "[ \t]"),
															}
														} else {
															__state.mark_failure(__pos, "[ \t]")
														};
														match __step_res {
															Matched(__newpos, __value) => {
																__repeat_pos = __newpos;
															},
															Failed => {
																break;
															},
														}
													}
													Matched(__repeat_pos, ())
												};
												match __seq_res {
													Matched(__pos, _) => {
														let __seq_res = {
															__state.suppress_fail += 1;
															let __assert_res = slice_eq(__input, __state, __pos, ">>>#");
															__state.suppress_fail -= 1;
															match __assert_res {
																Failed => Matched(__pos, ()),
																Matched(..) => Failed,
															}
														};
														match __seq_res {
															Matched(__pos, _) => {
																let mut __repeat_pos = __pos;
																loop {
																	let __pos = __repeat_pos;
																	let __step_res = if __input.len() > __pos {
																		let (__ch, __next) = char_range_at(__input, __pos);
																		match __ch {
																			'\n' => __state.mark_failure(__pos, "[^\n]"),
																			_ => Matched(__next, ()),
																		}
																	} else {
																		__state.mark_failure(__pos, "[^\n]")
																	};
																	match __step_res {
																		Matched(__newpos, __value) => {
																			__repeat_pos = __newpos;
																		},
																		Failed => {
																			break;
																		},
																	}
																}
																Matched(__repeat_pos, ())
															},
															Failed => Failed,
														}
													},
													Failed => Failed,
												}
											} {
												Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
												Failed => Failed,
											}
										};
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									Matched(__repeat_pos, __repeat_value)
								};
								match __seq_res {
									Matched(__pos, lines) => {
										let __seq_res = if __input.len() > __pos {
											let (__ch, __next) = char_range_at(__input, __pos);
											match __ch {
												'\n' => Matched(__next, ()),
												_ => __state.mark_failure(__pos, "[\n]"),
											}
										} else {
											__state.mark_failure(__pos, "[\n]")
										};
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = {
													let mut __repeat_pos = __pos;
													loop {
														let __pos = __repeat_pos;
														let __step_res = if __input.len() > __pos {
															let (__ch, __next) = char_range_at(__input, __pos);
															match __ch {
																' ' | '\t' => Matched(__next, ()),
																_ => __state.mark_failure(__pos, "[ \t]"),
															}
														} else {
															__state.mark_failure(__pos, "[ \t]")
														};
														match __step_res {
															Matched(__newpos, __value) => {
																__repeat_pos = __newpos;
															},
															Failed => {
																break;
															},
														}
													}
													Matched(__repeat_pos, ())
												};
												match __seq_res {
													Matched(__pos, _) => {
														let __seq_res = slice_eq(__input, __state, __pos, ">>>#");
														match __seq_res {
															Matched(__pos, _) => {
																match {
																	#[cfg(feature = "vonuvoli_values_string")]
																	let outcome = {
																		if lines.is_empty() {
																			Ok(values::string_immutable_new_empty().into())
																		} else {
																			let mut error = None;
																			let (padding, padding_text) = if let Some(first_line) = lines.first() {
																				let mut padding = 0;
																				for (offset, character) in first_line.char_indices() {
																					match character {
																						' ' | '\t' => padding = offset + 1,
																						_ => break,
																					}
																				}
																				let (padding_text, _) = first_line.split_at(padding);
																				(padding, padding_text)
																			} else {
																				if error.is_none() {
																					error = Some(Err("4634f63b"));
																				}
																				(0, "")
																			};
																			let mut trimmed_lines = Vec::with_capacity(lines.len());
																			for line in lines.iter() {
																				if !line.is_char_boundary(padding) {
																					if error.is_none() {
																						error = Some(Err("d9b907c8"));
																					}
																					break;
																				}
																				let (line_padding, line_rest) = line.split_at(padding);
																				if !str::eq(line_padding, padding_text) {
																					if error.is_none() {
																						error = Some(Err("c2292111"));
																					}
																					break;
																				}
																				if line_rest.is_empty() && trimmed_lines.is_empty() {
																					continue;
																				}
																				trimmed_lines.push(line_rest);
																			}
																			loop {
																				if let Some(last_line) = trimmed_lines.pop() {
																					if !last_line.is_empty() {
																						trimmed_lines.push(last_line);
																						break;
																					}
																				} else {
																					break;
																				}
																			}
																			if let Some(error) = error {
																				error
																			} else {
																				let mut string = String::with_capacity(128 * trimmed_lines.len());
																				for line in trimmed_lines {
																					string.push_str(line);
																					string.push('\n');
																				}
																				let string = values::string_immutable_new(string);
																				Ok(string.into())
																			}
																		}
																	};
																	#[cfg(not(feature = "vonuvoli_values_string"))]
																	let outcome = Err("strings are not supported");
																	outcome
																} {
																	Ok(res) => Matched(__pos, res),
																	Err(expected) => {
																		__state.mark_failure(__pos, expected);
																		Failed
																	},
																}
															},
															Failed => Failed,
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_bytes<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = __parse_bytes_quoted(__input, __state, __pos);
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => __parse_bytes_array(__input, __state, __pos),
		}
	}
}

fn __parse_bytes_quoted<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#u8");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => {
					let __choice_res = slice_eq(__input, __state, __pos, "#U8");
					match __choice_res {
						Matched(__pos, __value) => Matched(__pos, __value),
						Failed => slice_eq(__input, __state, __pos, "#bytes"),
					}
				},
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "\"");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __step_res = __parse_string_character(__input, __state, __pos);
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							Matched(__repeat_pos, __repeat_value)
						};
						match __seq_res {
							Matched(__pos, elements) => {
								let __seq_res = slice_eq(__input, __state, __pos, "\"");
								match __seq_res {
									Matched(__pos, _) => {
										match {
											#[cfg(feature = "vonuvoli_values_bytes")]
											let outcome = Ok(values::bytes_immutable_clone_characters(elements.as_slice()).into());
											#[cfg(not(feature = "vonuvoli_values_bytes"))]
											let outcome = Err("strings are not supported");
											outcome
										} {
											Ok(res) => Matched(__pos, res),
											Err(expected) => {
												__state.mark_failure(__pos, expected);
												Failed
											},
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_bytes_array<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let __choice_res = slice_eq(__input, __state, __pos, "#u8");
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => {
					let __choice_res = slice_eq(__input, __state, __pos, "#U8");
					match __choice_res {
						Matched(__pos, __value) => Matched(__pos, __value),
						Failed => slice_eq(__input, __state, __pos, "#bytes"),
					}
				},
			}
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = slice_eq(__input, __state, __pos, "(");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = {
									let mut __repeat_pos = __pos;
									let mut __repeat_value = vec![];
									loop {
										let __pos = __repeat_pos;
										let __pos = if __repeat_value.len() > 0 {
											let __sep_res = __parse_space(__input, __state, __pos);
											match __sep_res {
												Matched(__newpos, _) => __newpos,
												Failed => break,
											}
										} else {
											__pos
										};
										let __step_res = __parse_bytes_byte(__input, __state, __pos);
										match __step_res {
											Matched(__newpos, __value) => {
												__repeat_pos = __newpos;
												__repeat_value.push(__value);
											},
											Failed => {
												break;
											},
										}
									}
									Matched(__repeat_pos, __repeat_value)
								};
								match __seq_res {
									Matched(__pos, elements) => {
										let __seq_res = match __parse_space(__input, __state, __pos) {
											Matched(__newpos, _) => Matched(__newpos, ()),
											Failed => Matched(__pos, ()),
										};
										match __seq_res {
											Matched(__pos, _) => {
												let __seq_res = slice_eq(__input, __state, __pos, ")");
												match __seq_res {
													Matched(__pos, _) => {
														match {
															#[cfg(feature = "vonuvoli_values_bytes")]
															let outcome = Ok(values::bytes_immutable_new(elements).into());
															#[cfg(not(feature = "vonuvoli_values_bytes"))]
															let outcome = Err("bytes not supported");
															outcome
														} {
															Ok(res) => Matched(__pos, res),
															Err(expected) => {
																__state.mark_failure(__pos, expected);
																Failed
															},
														}
													},
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_bytes_byte<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<u8>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = {
			let str_start = __pos;
			match {
				let mut __repeat_pos = __pos;
				let mut __repeat_value = vec![];
				loop {
					let __pos = __repeat_pos;
					let __step_res = if __input.len() > __pos {
						let (__ch, __next) = char_range_at(__input, __pos);
						match __ch {
							'0' ..= '9' => Matched(__next, ()),
							_ => __state.mark_failure(__pos, "[0-9]"),
						}
					} else {
						__state.mark_failure(__pos, "[0-9]")
					};
					match __step_res {
						Matched(__newpos, __value) => {
							__repeat_pos = __newpos;
							__repeat_value.push(__value);
						},
						Failed => {
							break;
						},
					}
				}
				if __repeat_value.len() >= 1 {
					Matched(__repeat_pos, ())
				} else {
					Failed
				}
			} {
				Matched(__newpos, _) => Matched(__newpos, &__input[str_start .. __newpos]),
				Failed => Failed,
			}
		};
		match __seq_res {
			Matched(__pos, value) =>
				match { u8::from_str(value).map_err(|_| "invalid byte syntax") } {
					Ok(res) => Matched(__pos, res),
					Err(expected) => {
						__state.mark_failure(__pos, expected);
						Failed
					},
				},
			Failed => Failed,
		}
	}
}

fn __parse_constant<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = {
			let __seq_res = slice_eq(__input, __state, __pos, "#void");
			match __seq_res {
				Matched(__pos, _) => Matched(__pos, { constants::VOID.into() }),
				Failed => Failed,
			}
		};
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __seq_res = slice_eq(__input, __state, __pos, "#undefined");
				match __seq_res {
					Matched(__pos, _) => Matched(__pos, { constants::UNDEFINED.into() }),
					Failed => Failed,
				}
			},
		}
	}
}

fn __parse_comment<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		__state.suppress_fail += 1;
		let res = {
			let __choice_res = {
				let mut __repeat_pos = __pos;
				let mut __repeat_value = vec![];
				loop {
					let __pos = __repeat_pos;
					let __step_res = __parse_comment_line(__input, __state, __pos);
					match __step_res {
						Matched(__newpos, __value) => {
							__repeat_pos = __newpos;
							__repeat_value.push(__value);
						},
						Failed => {
							break;
						},
					}
				}
				if __repeat_value.len() >= 1 {
					Matched(__repeat_pos, ())
				} else {
					Failed
				}
			};
			match __choice_res {
				Matched(__pos, __value) => Matched(__pos, __value),
				Failed => {
					let __choice_res = {
						let mut __repeat_pos = __pos;
						let mut __repeat_value = vec![];
						loop {
							let __pos = __repeat_pos;
							let __step_res = __parse_comment_nested(__input, __state, __pos);
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
									__repeat_value.push(__value);
								},
								Failed => {
									break;
								},
							}
						}
						if __repeat_value.len() >= 1 {
							Matched(__repeat_pos, ())
						} else {
							Failed
						}
					};
					match __choice_res {
						Matched(__pos, __value) => Matched(__pos, __value),
						Failed => {
							let mut __repeat_pos = __pos;
							let mut __repeat_value = vec![];
							loop {
								let __pos = __repeat_pos;
								let __step_res = __parse_comment_value(__input, __state, __pos);
								match __step_res {
									Matched(__newpos, __value) => {
										__repeat_pos = __newpos;
										__repeat_value.push(__value);
									},
									Failed => {
										break;
									},
								}
							}
							if __repeat_value.len() >= 1 {
								Matched(__repeat_pos, ())
							} else {
								Failed
							}
						},
					}
				},
			}
		};
		__state.suppress_fail -= 1;
		res
	}
}

fn __parse_comment_line<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		__state.suppress_fail += 1;
		let res = {
			let __seq_res = slice_eq(__input, __state, __pos, ";");
			match __seq_res {
				Matched(__pos, _) => {
					let __seq_res = {
						let mut __repeat_pos = __pos;
						loop {
							let __pos = __repeat_pos;
							let __step_res = if __input.len() > __pos {
								let (__ch, __next) = char_range_at(__input, __pos);
								match __ch {
									'\n' => __state.mark_failure(__pos, "[^\n]"),
									_ => Matched(__next, ()),
								}
							} else {
								__state.mark_failure(__pos, "[^\n]")
							};
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
								},
								Failed => {
									break;
								},
							}
						}
						Matched(__repeat_pos, ())
					};
					match __seq_res {
						Matched(__pos, _) => slice_eq(__input, __state, __pos, "\n"),
						Failed => Failed,
					}
				},
				Failed => Failed,
			}
		};
		__state.suppress_fail -= 1;
		res
	}
}

fn __parse_comment_nested<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		__state.suppress_fail += 1;
		let res = {
			let __seq_res = slice_eq(__input, __state, __pos, "#|");
			match __seq_res {
				Matched(__pos, _) => {
					let __seq_res = {
						let mut __repeat_pos = __pos;
						loop {
							let __pos = __repeat_pos;
							let __step_res = {
								let __seq_res = {
									__state.suppress_fail += 1;
									let __assert_res = {
										let __choice_res = slice_eq(__input, __state, __pos, "#|");
										match __choice_res {
											Matched(__pos, __value) => Matched(__pos, __value),
											Failed => slice_eq(__input, __state, __pos, "|#"),
										}
									};
									__state.suppress_fail -= 1;
									match __assert_res {
										Failed => Matched(__pos, ()),
										Matched(..) => Failed,
									}
								};
								match __seq_res {
									Matched(__pos, _) => any_char(__input, __state, __pos),
									Failed => Failed,
								}
							};
							match __step_res {
								Matched(__newpos, __value) => {
									__repeat_pos = __newpos;
								},
								Failed => {
									break;
								},
							}
						}
						Matched(__repeat_pos, ())
					};
					match __seq_res {
						Matched(__pos, _) => {
							let __seq_res = {
								let mut __repeat_pos = __pos;
								loop {
									let __pos = __repeat_pos;
									let __step_res = __parse_comment_nested(__input, __state, __pos);
									match __step_res {
										Matched(__newpos, __value) => {
											__repeat_pos = __newpos;
										},
										Failed => {
											break;
										},
									}
								}
								Matched(__repeat_pos, ())
							};
							match __seq_res {
								Matched(__pos, _) => {
									let __seq_res = {
										let mut __repeat_pos = __pos;
										loop {
											let __pos = __repeat_pos;
											let __step_res = {
												let __seq_res = {
													__state.suppress_fail += 1;
													let __assert_res = {
														let __choice_res = slice_eq(__input, __state, __pos, "#|");
														match __choice_res {
															Matched(__pos, __value) => Matched(__pos, __value),
															Failed => slice_eq(__input, __state, __pos, "|#"),
														}
													};
													__state.suppress_fail -= 1;
													match __assert_res {
														Failed => Matched(__pos, ()),
														Matched(..) => Failed,
													}
												};
												match __seq_res {
													Matched(__pos, _) => any_char(__input, __state, __pos),
													Failed => Failed,
												}
											};
											match __step_res {
												Matched(__newpos, __value) => {
													__repeat_pos = __newpos;
												},
												Failed => {
													break;
												},
											}
										}
										Matched(__repeat_pos, ())
									};
									match __seq_res {
										Matched(__pos, _) => slice_eq(__input, __state, __pos, "|#"),
										Failed => Failed,
									}
								},
								Failed => Failed,
							}
						},
						Failed => Failed,
					}
				},
				Failed => Failed,
			}
		};
		__state.suppress_fail -= 1;
		res
	}
}

fn __parse_comment_value<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = slice_eq(__input, __state, __pos, "#;");
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = match __parse_whitespace(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) =>
						match __parse_value(__input, __state, __pos) {
							Matched(pos, _) => Matched(pos, ()),
							Failed => Failed,
						},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_whitespace<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		__state.suppress_fail += 1;
		let res = {
			let mut __repeat_pos = __pos;
			let mut __repeat_value = vec![];
			loop {
				let __pos = __repeat_pos;
				let __step_res = if __input.len() > __pos {
					let (__ch, __next) = char_range_at(__input, __pos);
					match __ch {
						' ' | '\t' | '\n' => Matched(__next, ()),
						_ => __state.mark_failure(__pos, "[ \t\n]"),
					}
				} else {
					__state.mark_failure(__pos, "[ \t\n]")
				};
				match __step_res {
					Matched(__newpos, __value) => {
						__repeat_pos = __newpos;
						__repeat_value.push(__value);
					},
					Failed => {
						break;
					},
				}
			}
			if __repeat_value.len() >= 1 {
				Matched(__repeat_pos, ())
			} else {
				Failed
			}
		};
		__state.suppress_fail -= 1;
		res
	}
}

fn __parse_space<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<()>
{
	#![allow(non_snake_case, unused)]
	{
		let mut __repeat_pos = __pos;
		let mut __repeat_value = vec![];
		loop {
			let __pos = __repeat_pos;
			let __step_res = {
				let __choice_res = __parse_whitespace(__input, __state, __pos);
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => __parse_comment(__input, __state, __pos),
				}
			};
			match __step_res {
				Matched(__newpos, __value) => {
					__repeat_pos = __newpos;
					__repeat_value.push(__value);
				},
				Failed => {
					break;
				},
			}
		}
		if __repeat_value.len() >= 1 {
			Matched(__repeat_pos, ())
		} else {
			Failed
		}
	}
}

fn __parse_script<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<Vec<values::Value>>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match __parse_space(__input, __state, __pos) {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					let mut __repeat_value = vec![];
					loop {
						let __pos = __repeat_pos;
						let __pos = if __repeat_value.len() > 0 {
							let __sep_res = match __parse_space(__input, __state, __pos) {
								Matched(__newpos, _) => Matched(__newpos, ()),
								Failed => Matched(__pos, ()),
							};
							match __sep_res {
								Matched(__newpos, _) => __newpos,
								Failed => break,
							}
						} else {
							__pos
						};
						let __step_res = __parse_value(__input, __state, __pos);
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
								__repeat_value.push(__value);
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, __repeat_value)
				};
				match __seq_res {
					Matched(__pos, values) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { values }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_tests<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<Vec<tests::TestCase>>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match __parse_space(__input, __state, __pos) {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = {
					let mut __repeat_pos = __pos;
					let mut __repeat_value = vec![];
					loop {
						let __pos = __repeat_pos;
						let __step_res = __parse_test(__input, __state, __pos);
						match __step_res {
							Matched(__newpos, __value) => {
								__repeat_pos = __newpos;
								__repeat_value.push(__value);
							},
							Failed => {
								break;
							},
						}
					}
					Matched(__repeat_pos, __repeat_value)
				};
				match __seq_res {
					Matched(__pos, tests) => {
						let __seq_res = match __parse_space(__input, __state, __pos) {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => Matched(__pos, { tests }),
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_test<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<tests::TestCase>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = match __parse_space(__input, __state, __pos) {
			Matched(__newpos, _) => Matched(__newpos, ()),
			Failed => Matched(__pos, ()),
		};
		match __seq_res {
			Matched(__pos, _) => {
				let __seq_res = __parse_test_case(__input, __state, __pos);
				match __seq_res {
					Matched(__pos, test) => {
						let __seq_res = match {
							let __seq_res = slice_eq(__input, __state, __pos, "//");
							match __seq_res {
								Matched(__pos, _) => {
									let __seq_res = match __parse_space(__input, __state, __pos) {
										Matched(__newpos, _) => Matched(__newpos, ()),
										Failed => Matched(__pos, ()),
									};
									match __seq_res {
										Matched(__pos, _) => {
											let __seq_res = match __parse_value(__input, __state, __pos) {
												Matched(pos, _) => Matched(pos, ()),
												Failed => Failed,
											};
											match __seq_res {
												Matched(__pos, _) =>
													match __parse_space(__input, __state, __pos) {
														Matched(__newpos, _) => Matched(__newpos, ()),
														Failed => Matched(__pos, ()),
													},
												Failed => Failed,
											}
										},
										Failed => Failed,
									}
								},
								Failed => Failed,
							}
						} {
							Matched(__newpos, _) => Matched(__newpos, ()),
							Failed => Matched(__pos, ()),
						};
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = match __parse_space(__input, __state, __pos) {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => Matched(__pos, { test }),
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_test_case<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<tests::TestCase>
{
	#![allow(non_snake_case, unused)]
	{
		let __seq_res = __parse_value(__input, __state, __pos);
		match __seq_res {
			Matched(__pos, value) => {
				let __seq_res = match __parse_space(__input, __state, __pos) {
					Matched(__newpos, _) => Matched(__newpos, ()),
					Failed => Matched(__pos, ()),
				};
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = slice_eq(__input, __state, __pos, "=>");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = match __parse_space(__input, __state, __pos) {
									Matched(__newpos, _) => Matched(__newpos, ()),
									Failed => Matched(__pos, ()),
								};
								match __seq_res {
									Matched(__pos, _) => {
										let __seq_res = __parse_test_action(__input, __state, __pos);
										match __seq_res {
											Matched(__pos, action) => {
												let __seq_res = match __parse_space(__input, __state, __pos) {
													Matched(__newpos, _) => Matched(__newpos, ()),
													Failed => Matched(__pos, ()),
												};
												match __seq_res {
													Matched(__pos, _) =>
														Matched(__pos, {
															tests::TestCase {
																expression : value,
																action : action,
																verbosity : tests::TestVerbosity::Default,
															}
														}),
													Failed => Failed,
												}
											},
											Failed => Failed,
										}
									},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			},
			Failed => Failed,
		}
	}
}

fn __parse_test_action<'input>(
	__input : &'input str,
	__state : &mut ParseState<'input>,
	__pos : usize,
) -> RuleResult<tests::TestAction>
{
	#![allow(non_snake_case, unused)]
	{
		let __choice_res = {
			let __seq_res = {
				let __seq_res = slice_eq(__input, __state, __pos, "!debug");
				match __seq_res {
					Matched(__pos, _) => {
						let __seq_res = __parse_space(__input, __state, __pos);
						match __seq_res {
							Matched(__pos, _) =>
								match __parse_value(__input, __state, __pos) {
									Matched(pos, _) => Matched(pos, ()),
									Failed => Failed,
								},
							Failed => Failed,
						}
					},
					Failed => Failed,
				}
			};
			match __seq_res {
				Matched(__pos, _) => Matched(__pos, { tests::TestAction::Debug }),
				Failed => Failed,
			}
		};
		match __choice_res {
			Matched(__pos, __value) => Matched(__pos, __value),
			Failed => {
				let __choice_res = {
					let __seq_res = {
						let __seq_res = slice_eq(__input, __state, __pos, "!fixme");
						match __seq_res {
							Matched(__pos, _) => {
								let __seq_res = __parse_space(__input, __state, __pos);
								match __seq_res {
									Matched(__pos, _) =>
										match __parse_value(__input, __state, __pos) {
											Matched(pos, _) => Matched(pos, ()),
											Failed => Failed,
										},
									Failed => Failed,
								}
							},
							Failed => Failed,
						}
					};
					match __seq_res {
						Matched(__pos, _) => Matched(__pos, { tests::TestAction::Skip }),
						Failed => Failed,
					}
				};
				match __choice_res {
					Matched(__pos, __value) => Matched(__pos, __value),
					Failed => {
						let __choice_res = {
							let __seq_res = slice_eq(__input, __state, __pos, "!ignore");
							match __seq_res {
								Matched(__pos, _) => Matched(__pos, { tests::TestAction::Ignore }),
								Failed => Failed,
							}
						};
						match __choice_res {
							Matched(__pos, __value) => Matched(__pos, __value),
							Failed => {
								let __seq_res = __parse_value(__input, __state, __pos);
								match __seq_res {
									Matched(__pos, value) => Matched(__pos, { tests::TestAction::Expect(value) }),
									Failed => Failed,
								}
							},
						}
					},
				}
			},
		}
	}
}

pub fn value<'input>(__input : &'input str) -> ParseResult<values::Value>
{
	#![allow(non_snake_case, unused)]
	let mut __state = ParseState::new();
	match __parse_value(__input, &mut __state, 0) {
		Matched(__pos, __value) =>
			if __pos == __input.len() {
				return Ok(__value);
			},
		_ => {},
	}
	let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
	Err(ParseError {
		line : __line,
		column : __col,
		offset : __state.max_err_pos,
		expected : __state.expected,
	})
}

pub fn value_sequence<'input>(__input : &'input str) -> ParseResult<Vec<values::Value>>
{
	#![allow(non_snake_case, unused)]
	let mut __state = ParseState::new();
	match __parse_value_sequence(__input, &mut __state, 0) {
		Matched(__pos, __value) =>
			if __pos == __input.len() {
				return Ok(__value);
			},
		_ => {},
	}
	let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
	Err(ParseError {
		line : __line,
		column : __col,
		offset : __state.max_err_pos,
		expected : __state.expected,
	})
}

pub fn script<'input>(__input : &'input str) -> ParseResult<Vec<values::Value>>
{
	#![allow(non_snake_case, unused)]
	let mut __state = ParseState::new();
	match __parse_script(__input, &mut __state, 0) {
		Matched(__pos, __value) =>
			if __pos == __input.len() {
				return Ok(__value);
			},
		_ => {},
	}
	let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
	Err(ParseError {
		line : __line,
		column : __col,
		offset : __state.max_err_pos,
		expected : __state.expected,
	})
}

pub fn tests<'input>(__input : &'input str) -> ParseResult<Vec<tests::TestCase>>
{
	#![allow(non_snake_case, unused)]
	let mut __state = ParseState::new();
	match __parse_tests(__input, &mut __state, 0) {
		Matched(__pos, __value) =>
			if __pos == __input.len() {
				return Ok(__value);
			},
		_ => {},
	}
	let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
	Err(ParseError {
		line : __line,
		column : __col,
		offset : __state.max_err_pos,
		expected : __state.expected,
	})
}

pub fn test<'input>(__input : &'input str) -> ParseResult<tests::TestCase>
{
	#![allow(non_snake_case, unused)]
	let mut __state = ParseState::new();
	match __parse_test(__input, &mut __state, 0) {
		Matched(__pos, __value) =>
			if __pos == __input.len() {
				return Ok(__value);
			},
		_ => {},
	}
	let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
	Err(ParseError {
		line : __line,
		column : __col,
		offset : __state.max_err_pos,
		expected : __state.expected,
	})
}
