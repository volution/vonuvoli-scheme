// Generated by rust-peg. Do not edit.
use self::RuleResult::{Matched, Failed};
use super::builtins::exports as builtins;
use super::constants::exports as constants;
use super::tests::exports as tests;
use super::values::exports as values;
use std::char;
use std::iter::Iterator;
use std::convert::Into;
use std::option::Option::Some;
use std::result::Result;
use std::result::Result::Ok;
use std::result::Result::Err;
use std::str::FromStr;
use std::string::String;
use std::vec::Vec;
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> {
    Matched(usize, T),
    Failed,
}
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write!(
            fmt,
            "error at {}:{}: expected ",
            self.line,
            self.column
        ))
;
        if self.expected.len() == 0 {
            try!(write!(fmt, "EOF"));
        } else if self.expected.len() == 1 {
            try!(write!(
                fmt,
                "`{}`",
                escape_default(self.expected.iter().next().unwrap())
            ));
        } else {
            let mut iter = self.expected.iter();
            try!(write!(
                fmt,
                "one of `{}`",
                escape_default(iter.next().unwrap())
            ));
            for elem in iter {
                try!(write!(fmt, ", `{}`", escape_default(elem)));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str {
        "parse error"
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str) -> RuleResult<()> {
# ! [ inline ] # ! [ allow ( dead_code ) ]    let l = m.len();
    if input.len() >= pos + l && &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else {
        state.mark_failure(pos, m)
    }
}
fn slice_eq_case_insensitive(
    input: &str,
    state: &mut ParseState,
    pos: usize,
    m: &'static str,
) -> RuleResult<()> {
# ! [ inline ] # ! [ allow ( dead_code ) ]    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() || input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize) -> RuleResult<()> {
# ! [ inline ] # ! [ allow ( dead_code ) ]    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else {
        state.mark_failure(pos, "<character>")
    }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let before = &input[..pos];
    let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
    let col = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
    (line, col)
}
impl<'input> ParseState<'input> {
    fn mark_failure(&mut self, pos: usize, expected: &'static str) -> RuleResult<()> {
        if self.suppress_fail == 0 {
            if pos > self.max_err_pos {
                self.max_err_pos = pos;
                self.expected.clear();
            }
            if pos == self.max_err_pos {
                self.expected.insert(expected);
            }
        }
        Failed
    }
}
struct ParseState<'input> {
    max_err_pos: usize,
    suppress_fail: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl<'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState {
            max_err_pos: 0,
            suppress_fail: 0,
            expected: ::std::collections::HashSet::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }
}

fn __parse_value<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_abbreviation(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_list(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_array(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = __parse_values(__input, __state, __pos);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => __parse_atom(__input, __state, __pos),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_atom<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_boolean(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_number(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_symbol(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = __parse_character(__input, __state, __pos);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = __parse_string(__input, __state, __pos);
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res =
                                                    __parse_bytes(__input, __state, __pos);
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        __parse_constant(__input, __state, __pos)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_list<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_list_empty(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_list_proper(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_list_dotted(__input, __state, __pos),
                }
            }
        }
    }
}

fn __parse_list_proper<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = match __parse_space(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse_space(__input, __state, __pos);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_value(__input, __state, __pos);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, elements) => {
                                let __seq_res = match __parse_space(__input, __state, __pos) {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                Matched(__pos, {
                                                    builtins::list_collect(elements)
                                                })
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_list_dotted<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = match __parse_space(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse_space(__input, __state, __pos);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_value(__input, __state, __pos);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, __repeat_value)
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, elements) => {
                                let __seq_res = __parse_space(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ".");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    __parse_space(__input, __state, __pos);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res =
                                                            __parse_value(__input, __state, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, last) => {
                                                                let __seq_res =
                                                                    match __parse_space(
                                                                        __input,
                                                                        __state,
                                                                        __pos,
                                                                    ) {
                                                                        Matched(__newpos, _) => {
                                                                            Matched(__newpos, ())
                                                                        }
                                                                        Failed => {
                                                                            Matched(__pos, ())
                                                                        }
                                                                    };
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = slice_eq(
                                                                            __input,
                                                                            __state,
                                                                            __pos,
                                                                            ")",
                                                                        );
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                Matched(__pos, {
                                                                                    builtins::list_collect_dotted (elements, Some (last))
                                                                                })
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_list_empty<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => slice_eq(__input, __state, __pos, ")"),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#null"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                Matched(__pos, {
                    builtins::list_empty()
                })
            }
            Failed => Failed,
        }
    }
}

fn __parse_array<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#array");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = __parse_space(__input, __state, __pos);
                                            match __sep_res {
                                                Matched(__newpos, _) => __newpos,
                                                Failed => break,
                                            }
                                        } else {
                                            __pos
                                        };
                                        let __step_res = __parse_value(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, elements) => {
                                        let __seq_res =
                                            match __parse_space(__input, __state, __pos) {
                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                Failed => Matched(__pos, ()),
                                            };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        Matched(__pos, {
                                                            values::array_immutable_new(elements)
                                                                .into()
                                                        })
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_values<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#values");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = __parse_space(__input, __state, __pos);
                                            match __sep_res {
                                                Matched(__newpos, _) => __newpos,
                                                Failed => break,
                                            }
                                        } else {
                                            __pos
                                        };
                                        let __step_res = __parse_value(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, elements) => {
                                        let __seq_res =
                                            match __parse_space(__input, __state, __pos) {
                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                Failed => Matched(__pos, ()),
                                            };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        Matched(__pos, {
                                                            values::values_new_from_vec(elements)
                                                                .into()
                                                        })
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_abbreviation<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = __parse_abbreviation_prefix(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, abbreviation) => {
                let __seq_res = match __parse_whitespace(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_value(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, value) => {
                                Matched(__pos, {
                                    builtins::list_collect(vec![abbreviation, value])
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_abbreviation_prefix<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __choice_res = slice_eq(__input, __state, __pos, "'");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "`");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, ",@");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => slice_eq(__input, __state, __pos, ","),
                                }
                            }
                        }
                    }
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    match value {
                        "'" => Ok(values::symbol_clone_str("quote").into()),
                        "`" => Ok(values::symbol_clone_str("quasiquote").into()),
                        "," => Ok(values::symbol_clone_str("unquote").into()),
                        ",@" => Ok(values::symbol_clone_str("unquote-splicing").into()),
                        _ => Err("a2007ac4"),
                    }
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_boolean<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_boolean_true(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_boolean_false(__input, __state, __pos),
        }
    }
}

fn __parse_boolean_true<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "#true");
            match __seq_res {
                Matched(__pos, _) => {
                    Matched(__pos, {
                        constants::TRUE.into()
                    })
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "#t");
                match __seq_res {
                    Matched(__pos, _) => {
                        Matched(__pos, {
                            constants::TRUE.into()
                        })
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_boolean_false<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "#false");
            match __seq_res {
                Matched(__pos, _) => {
                    Matched(__pos, {
                        constants::FALSE.into()
                    })
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "#f");
                match __seq_res {
                    Matched(__pos, _) => {
                        Matched(__pos, {
                            constants::FALSE.into()
                        })
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_number<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = __parse_number_real(__input, __state, __pos);
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => __parse_number_integer(__input, __state, __pos),
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = __parse_symbol_character_glyph(__input, __state, __pos);
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        Matched(__pos, {
                            value.into()
                        })
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_sign<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = slice_eq(__input, __state, __pos, "+");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => slice_eq(__input, __state, __pos, "-"),
        }
    }
}

fn __parse_number_integer<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_number_integer_2(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_number_integer_8(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_number_integer_10(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => __parse_number_integer_16(__input, __state, __pos),
                        }
                    }
                }
            }
        }
    }
}

fn __parse_number_integer_2<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#b");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#B"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'1' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-1]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-1]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                            Failed => Failed,
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            i64::from_str_radix(value, 2)
                                .map(|value| values::number_i64(value).into())
                                .map_err(|_| "invalid real syntax")
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_integer_8<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#o");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#O"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'7' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-7]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-7]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                            Failed => Failed,
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            i64::from_str_radix(value, 8)
                                .map(|value| values::number_i64(value).into())
                                .map_err(|_| "invalid real syntax")
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_integer_10<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = match {
            let __choice_res = slice_eq(__input, __state, __pos, "#d");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#D"),
            }
        } {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-9]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                            Failed => Failed,
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            i64::from_str_radix(value, 10)
                                .map(|value| values::number_i64(value).into())
                                .map_err(|_| "invalid real syntax")
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_integer_16<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#x");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#X"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __choice_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '0'...'9' | 'a'...'f' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[0-9a-f]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[0-9a-f]")
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        Matched(__repeat_pos, ())
                                    } else {
                                        Failed
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = vec![];
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = if __input.len() > __pos {
                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                match __ch {
                                                    '0'...'9' | 'A'...'F' => Matched(__next, ()),
                                                    _ => __state.mark_failure(__pos, "[0-9A-F]"),
                                                }
                                            } else {
                                                __state.mark_failure(__pos, "[0-9A-F]")
                                            };
                                            match __step_res {
                                                Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 {
                                            Matched(__repeat_pos, ())
                                        } else {
                                            Failed
                                        }
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            i64::from_str_radix(value, 16)
                                .map(|value| values::number_i64(value).into())
                                .map_err(|_| "invalid real syntax")
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_number_real_variant_1(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_number_real_variant_2(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_number_real_variant_3(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res =
                                    __parse_number_real_variant_4(__input, __state, __pos);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res =
                                            __parse_number_real_inf(__input, __state, __pos);
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = __parse_number_real_nan(
                                                    __input,
                                                    __state,
                                                    __pos,
                                                );
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        __parse_number_real_epsilon(
                                                            __input,
                                                            __state,
                                                            __pos,
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_number_real_variant_1<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[0-9]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ".");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __step_res = if __input.len() > __pos {
                                                    let (__ch, __next) =
                                                        char_range_at(__input, __pos);
                                                    match __ch {
                                                        '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[0-9]")
                                                };
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                Matched(__repeat_pos, ())
                                            } else {
                                                Failed
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                match __parse_number_real_exponent(
                                                    __input,
                                                    __state,
                                                    __pos,
                                                ) {
                                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                                    Failed => Matched(__pos, ()),
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    f64::from_str(value)
                        .map(|value| values::number_f64(value).into())
                        .map_err(|_| "invalid real syntax")
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_variant_2<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[0-9]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ".");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        match __parse_number_real_exponent(
                                            __input,
                                            __state,
                                            __pos,
                                        ) {
                                            Matched(__newpos, _) => Matched(__newpos, ()),
                                            Failed => Matched(__pos, ()),
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    f64::from_str(value)
                        .map(|value| values::number_f64(value).into())
                        .map_err(|_| "invalid real syntax")
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_variant_3<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ".");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[0-9]")
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        Matched(__repeat_pos, ())
                                    } else {
                                        Failed
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        match __parse_number_real_exponent(
                                            __input,
                                            __state,
                                            __pos,
                                        ) {
                                            Matched(__newpos, _) => Matched(__newpos, ()),
                                            Failed => Matched(__pos, ()),
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    f64::from_str(value)
                        .map(|value| values::number_f64(value).into())
                        .map_err(|_| "invalid real syntax")
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_variant_4<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[0-9]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                __parse_number_real_exponent(__input, __state, __pos)
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    f64::from_str(value)
                        .map(|value| values::number_f64(value).into())
                        .map_err(|_| "invalid real syntax")
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_inf<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_number_real_inf_positive(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_number_real_inf_negative(__input, __state, __pos),
        }
    }
}

fn __parse_number_real_inf_positive<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "+");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "inf");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::INF_POSITIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_inf_negative<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "-");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "inf");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::INF_NEGATIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_nan<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_number_real_nan_positive(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_number_real_nan_negative(__input, __state, __pos),
        }
    }
}

fn __parse_number_real_nan_positive<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "+");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "nan");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::NAN_POSITIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_nan_negative<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "-");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "nan");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::NAN_NEGATIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_epsilon<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_number_real_epsilon_positive(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_number_real_epsilon_negative(__input, __state, __pos),
        }
    }
}

fn __parse_number_real_epsilon_positive<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "+");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "epsilon");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::EPSILON_POSITIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_epsilon_negative<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, "-");
            __state.suppress_fail -= 1;
            match __assert_res {
                Matched(_, __value) => Matched(__pos, __value),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_number_sign(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "epsilon");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match slice_eq(__input, __state, __pos, ".0") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            constants::EPSILON_NEGATIVE.into()
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_number_real_exponent<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "e");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "E"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = match __parse_number_sign(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[0-9]")
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_character<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_character_glyph(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_character_escaped(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_character_named(__input, __state, __pos),
                }
            }
        }
    }
}

fn __parse_character_glyph<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "#\\");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match any_char(__input, __state, __pos) {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, glyph) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = match __parse_atom(__input, __state, __pos) {
                                Matched(pos, _) => Matched(pos, ()),
                                Failed => Failed,
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                Matched(__pos, {
                                    values::character(glyph.chars().next().expect("36da249a"))
                                        .into()
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_character_escaped<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#\\x");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "#\\X"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __choice_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '0'...'9' | 'a'...'f' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[0-9a-f]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[0-9a-f]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'9' | 'A'...'F' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-9A-F]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-9A-F]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            u32::from_str_radix(value, 16)
                                .map_err(|_| "invalid character syntax")
                                .and_then(|value| {
                                    char::from_u32(value).ok_or("invalid character value")
                                })
                                .map(|character| values::character(character).into())
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_character_named<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "#\\");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res =
                    {
                        let str_start = __pos;
                        match {
                            let __choice_res = slice_eq(__input, __state, __pos, "alarm");
                            match __choice_res {
                                Matched(__pos, __value) => Matched(__pos, __value),
                                Failed => {
                                    let __choice_res =
                                        slice_eq(__input, __state, __pos, "backspace");
                                    match __choice_res {
                                        Matched(__pos, __value) => Matched(__pos, __value),
                                        Failed => {
                                            let __choice_res =
                                                slice_eq(__input, __state, __pos, "delete");
                                            match __choice_res {
                                                Matched(__pos, __value) => Matched(__pos, __value),
                                                Failed => {
                                                    let __choice_res =
                                                        slice_eq(__input, __state, __pos, "escape");
                                                    match __choice_res {
                                                        Matched(__pos, __value) => {
                                                            Matched(__pos, __value)
                                                        }
                                                        Failed => {
                                                            let __choice_res = slice_eq(
                                                                __input,
                                                                __state,
                                                                __pos,
                                                                "newline",
                                                            );
                                                            match __choice_res {
                                                                Matched(__pos, __value) => {
                                                                    Matched(__pos, __value)
                                                                }
                                                                Failed => {
                                                                    let __choice_res = slice_eq(
                                                                        __input,
                                                                        __state,
                                                                        __pos,
                                                                        "null",
                                                                    );
                                                                    match __choice_res {
                                                                        Matched(__pos, __value) => {
                                                                            Matched(__pos, __value)
                                                                        }
                                                                        Failed => {
                                                                            let __choice_res =
                                                                                slice_eq(
                                                                                    __input,
                                                                                    __state,
                                                                                    __pos,
                                                                                    "return",
                                                                                );
                                                                            match __choice_res {
                                                                                Matched ( __pos , __value ) => Matched ( __pos , __value ),
                                                                                Failed => {
                                                                                    let __choice_res = slice_eq ( __input , __state , __pos , "space" ) ;
                                                                                    match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "tab" ) }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } {
                            Matched(__newpos, _) => {
                                Matched(__newpos, &__input[str_start..__newpos])
                            }
                            Failed => Failed,
                        }
                    };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            match value {
                                "alarm" => Ok(values::character(7 as char).into()),
                                "backspace" => Ok(values::character(8 as char).into()),
                                "delete" => Ok(values::character(127 as char).into()),
                                "escape" => Ok(values::character(27 as char).into()),
                                "newline" => Ok(values::character(10 as char).into()),
                                "null" => Ok(values::character(0 as char).into()),
                                "return" => Ok(values::character(13 as char).into()),
                                "space" => Ok(values::character(32 as char).into()),
                                "tab" => Ok(values::character(9 as char).into()),
                                _ => Err("fcfc68be"),
                            }
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_symbol<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_symbol_multiple_characters(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_symbol_single_character(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_symbol_string(__input, __state, __pos),
                }
            }
        }
    }
}

fn __parse_symbol_single_character<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let __assert_res = slice_eq(__input, __state, __pos, ".");
            __state.suppress_fail -= 1;
            match __assert_res {
                Failed => Matched(__pos, ()),
                Matched(..) => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match __parse_symbol_character_glyph(__input, __state, __pos) {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        Matched(__pos, {
                            values::symbol_clone_str(value).into()
                        })
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_symbol_multiple_characters<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = __parse_symbol_character_glyph(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res =
                                __parse_symbol_character_glyph(__input, __state, __pos);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                Matched(__pos, {
                    values::symbol_clone_str(value).into()
                })
            }
            Failed => Failed,
        }
    }
}

fn __parse_symbol_character_glyph<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                'a'...'z' | 'A'...'Z' => Matched(__next, ()),
                _ => __state.mark_failure(__pos, "[a-zA-Z]"),
            }
        } else {
            __state.mark_failure(__pos, "[a-zA-Z]")
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '!' | '$' | '%' | '&' | '*' | '/' | ':' | '<' | '=' | '>' | '?' | '^' |
                        '_' | '~' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[!$%&*/:<=>?^_~]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[!$%&*/:<=>?^_~]")
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = if __input.len() > __pos {
                            let (__ch, __next) = char_range_at(__input, __pos);
                            match __ch {
                                '0'...'9' => Matched(__next, ()),
                                _ => __state.mark_failure(__pos, "[0-9]"),
                            }
                        } else {
                            __state.mark_failure(__pos, "[0-9]")
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '@' | '.' | '+' | '-' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[@.+-]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[@.+-]")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_symbol_string<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "|");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __step_res = __parse_symbol_string_character(__input, __state, __pos);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, elements) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "|");
                        match __seq_res {
                            Matched(__pos, _) => {
                                Matched(__pos, {
                                    values::symbol_clone_characters(elements.as_slice()).into()
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_symbol_string_character<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_symbol_string_character_glyph(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_string_character_escaped(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_string_character_named(__input, __state, __pos),
                }
            }
        }
    }
}

fn __parse_symbol_string_character_glyph<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match if __input.len() > __pos {
                let (__ch, __next) = char_range_at(__input, __pos);
                match __ch {
                    '|' | '\\' => __state.mark_failure(__pos, "[^|\\]"),
                    _ => Matched(__next, ()),
                }
            } else {
                __state.mark_failure(__pos, "[^|\\]")
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, glyph) => {
                Matched(__pos, {
                    glyph.chars().next().expect("56031166")
                })
            }
            Failed => Failed,
        }
    }
}

fn __parse_string<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_string_quoted(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_string_array(__input, __state, __pos),
        }
    }
}

fn __parse_string_quoted<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "\"");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __step_res = __parse_string_character(__input, __state, __pos);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, elements) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "\"");
                        match __seq_res {
                            Matched(__pos, _) => {
                                Matched(__pos, {
                                    values::string_immutable_clone_characters(elements.as_slice())
                                        .into()
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_character<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = __parse_string_character_glyph(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_string_character_escaped(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_string_character_named(__input, __state, __pos),
                }
            }
        }
    }
}

fn __parse_string_character_glyph<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match if __input.len() > __pos {
                let (__ch, __next) = char_range_at(__input, __pos);
                match __ch {
                    '"' | '\\' => __state.mark_failure(__pos, "[^\"\\]"),
                    _ => Matched(__next, ()),
                }
            } else {
                __state.mark_failure(__pos, "[^\"\\]")
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, glyph) => {
                Matched(__pos, {
                    glyph.chars().next().expect("61d18567")
                })
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_character_escaped<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "\\x");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, "\\X"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __choice_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '0'...'9' | 'a'...'f' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[0-9a-f]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[0-9a-f]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'9' | 'A'...'F' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-9A-F]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-9A-F]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                        match __seq_res {
                            Matched(__pos, _) => {
                                match {
                                    u32::from_str_radix(value, 16)
                                        .map_err(|_| "invalid character syntax")
                                        .and_then(|value| {
                                            char::from_u32(value).ok_or("invalid character value")
                                        })
                                } {
                                    Ok(res) => Matched(__pos, res),
                                    Err(expected) => {
                                        __state.mark_failure(__pos, expected);
                                        Failed
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_character_named<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "\\");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __choice_res = slice_eq(__input, __state, __pos, "a");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, "b");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = slice_eq(__input, __state, __pos, "t");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res =
                                                    slice_eq(__input, __state, __pos, "n");
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        slice_eq(__input, __state, __pos, "r")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, value) => {
                        match {
                            match value {
                                "a" => Ok(7 as char),
                                "b" => Ok(8 as char),
                                "n" => Ok(10 as char),
                                "r" => Ok(13 as char),
                                "t" => Ok(9 as char),
                                _ => Err("285687fe"),
                            }
                        } {
                            Ok(res) => Matched(__pos, res),
                            Err(expected) => {
                                __state.mark_failure(__pos, expected);
                                Failed
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_array<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "#string");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = __parse_space(__input, __state, __pos);
                                            match __sep_res {
                                                Matched(__newpos, _) => __newpos,
                                                Failed => break,
                                            }
                                        } else {
                                            __pos
                                        };
                                        let __step_res =
                                            __parse_string_array_character(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, elements) => {
                                        let __seq_res =
                                            match __parse_space(__input, __state, __pos) {
                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                Failed => Matched(__pos, ()),
                                            };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        Matched(__pos, {
                                                            values::string_immutable_clone_characters (elements.as_slice ()) .into ()
                                                        })
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_array_character<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<char> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '0'...'9' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[0-9]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[0-9]")
                    };
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    Matched(__repeat_pos, ())
                } else {
                    Failed
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    u32::from_str(value)
                        .map_err(|_| "invalid character syntax")
                        .and_then(|value| {
                            char::from_u32(value).ok_or("invalid character value")
                        })
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_bytes<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "#u8");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => {
                    let __choice_res = slice_eq(__input, __state, __pos, "#U8");
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => slice_eq(__input, __state, __pos, "#bytes"),
                    }
                }
            }
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = __parse_space(__input, __state, __pos);
                                            match __sep_res {
                                                Matched(__newpos, _) => __newpos,
                                                Failed => break,
                                            }
                                        } else {
                                            __pos
                                        };
                                        let __step_res =
                                            __parse_bytes_byte(__input, __state, __pos);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    Matched(__pos, elements) => {
                                        let __seq_res =
                                            match __parse_space(__input, __state, __pos) {
                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                Failed => Matched(__pos, ()),
                                            };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        Matched(__pos, {
                                                            values::bytes_immutable_new(elements)
                                                                .into()
                                                        })
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_bytes_byte<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<u8> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '0'...'9' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[0-9]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[0-9]")
                    };
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    Matched(__repeat_pos, ())
                } else {
                    Failed
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, value) => {
                match {
                    u8::from_str(value).map_err(|_| "invalid byte syntax")
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_constant<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "#void");
            match __seq_res {
                Matched(__pos, _) => {
                    Matched(__pos, {
                        constants::VOID.into()
                    })
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "#undefined");
                match __seq_res {
                    Matched(__pos, _) => {
                        Matched(__pos, {
                            constants::UNDEFINED.into()
                        })
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_comment<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        __state.suppress_fail += 1;
        let res = {
            let __choice_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_comment_line(__input, __state, __pos);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    Matched(__repeat_pos, ())
                } else {
                    Failed
                }
            };
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => {
                    let __choice_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_comment_nested(__input, __state, __pos);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    };
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = __parse_comment_value(__input, __state, __pos);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        }
                    }
                }
            }
        };
        __state.suppress_fail -= 1;
        res
    }
}

fn __parse_comment_line<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        __state.suppress_fail += 1;
        let res = {
            let __seq_res = slice_eq(__input, __state, __pos, ";");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '\n' => __state.mark_failure(__pos, "[^\n]"),
                                    _ => Matched(__next, ()),
                                }
                            } else {
                                __state.mark_failure(__pos, "[^\n]")
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                        Matched(__pos, _) => slice_eq(__input, __state, __pos, "\n"),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        __state.suppress_fail -= 1;
        res
    }
}

fn __parse_comment_nested<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        __state.suppress_fail += 1;
        let res = {
            let __seq_res = slice_eq(__input, __state, __pos, "#|");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = {
                                        let __choice_res = slice_eq(__input, __state, __pos, "#|");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => slice_eq(__input, __state, __pos, "|#"),
                                        }
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = any_char(__input, __state, __pos);
                                        match __seq_res {
                                            Matched(__pos, _) => any_char(__input, __state, __pos),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, ())
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res =
                                        __parse_comment_nested(__input, __state, __pos);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, ())
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let mut __repeat_pos = __pos;
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let __assert_res = {
                                                        let __choice_res =
                                                            slice_eq(__input, __state, __pos, "#|");
                                                        match __choice_res {
                                                            Matched(__pos, __value) => {
                                                                Matched(__pos, __value)
                                                            }
                                                            Failed => {
                                                                slice_eq(
                                                                    __input,
                                                                    __state,
                                                                    __pos,
                                                                    "|#",
                                                                )
                                                            }
                                                        }
                                                    };
                                                    __state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        Failed => Matched(__pos, ()),
                                                        Matched(..) => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res =
                                                            any_char(__input, __state, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                any_char(__input, __state, __pos)
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __step_res {
                                                Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                }
                                                Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        Matched(__repeat_pos, ())
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            slice_eq(__input, __state, __pos, "|#")
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        __state.suppress_fail -= 1;
        res
    }
}

fn __parse_comment_value<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = slice_eq(__input, __state, __pos, "#;");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_whitespace(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        match __parse_value(__input, __state, __pos) {
                            Matched(pos, _) => Matched(pos, ()),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_whitespace<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        __state.suppress_fail += 1;
        let res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __step_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        ' ' | '\t' | '\n' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[ \t\n]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[ \t\n]")
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            if __repeat_value.len() >= 1 {
                Matched(__repeat_pos, ())
            } else {
                Failed
            }
        };
        __state.suppress_fail -= 1;
        res
    }
}

fn __parse_space<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {# ! [ allow ( non_snake_case , unused ) ]    {
        let mut __repeat_pos = __pos;
        let mut __repeat_value = vec![];
        loop {
            let __pos = __repeat_pos;
            let __step_res = {
                let __choice_res = __parse_whitespace(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_comment(__input, __state, __pos),
                }
            };
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                }
                Failed => {
                    break;
                }
            }
        }
        if __repeat_value.len() >= 1 {
            Matched(__repeat_pos, ())
        } else {
            Failed
        }
    }
}

fn __parse_script<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<values::Value>> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = match __parse_space(__input, __state, __pos) {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = match __parse_space(__input, __state, __pos) {
                                Matched(__newpos, _) => Matched(__newpos, ()),
                                Failed => Matched(__pos, ()),
                            };
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = __parse_value(__input, __state, __pos);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, values) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                Matched(__pos, {
                                    values
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_tests<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<tests::TestCase>> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = match __parse_space(__input, __state, __pos) {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __step_res = __parse_test(__input, __state, __pos);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, tests) => {
                        let __seq_res = match __parse_space(__input, __state, __pos) {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                Matched(__pos, {
                                    tests
                                })
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_test<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<tests::TestCase> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = match __parse_space(__input, __state, __pos) {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_test_case(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, test) => {
                        let __seq_res = match {
                            let __seq_res = slice_eq(__input, __state, __pos, "//");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = match __parse_space(__input, __state, __pos) {
                                        Matched(__newpos, _) => Matched(__newpos, ()),
                                        Failed => Matched(__pos, ()),
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res =
                                                match __parse_value(__input, __state, __pos) {
                                                    Matched(pos, _) => Matched(pos, ()),
                                                    Failed => Failed,
                                                };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    match __parse_space(__input, __state, __pos) {
                                                        Matched(__newpos, _) => {
                                                            Matched(__newpos, ())
                                                        }
                                                        Failed => Matched(__pos, ()),
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match __parse_space(__input, __state, __pos) {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        Matched(__pos, {
                                            test
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_test_case<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<tests::TestCase> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __seq_res = __parse_value(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, value) => {
                let __seq_res = match __parse_space(__input, __state, __pos) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "=>");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match __parse_space(__input, __state, __pos) {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res =
                                            __parse_test_action(__input, __state, __pos);
                                        match __seq_res {
                                            Matched(__pos, action) => {
                                                let __seq_res =
                                                    match __parse_space(__input, __state, __pos) {
                                                        Matched(__newpos, _) => {
                                                            Matched(__newpos, ())
                                                        }
                                                        Failed => Matched(__pos, ()),
                                                    };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        Matched(__pos, {
                                                            tests::TestCase {
                                                                expression: value,
                                                                action: action,
                                                                verbosity:
                                                                    tests::TestVerbosity::Default,
                                                            }
                                                        })
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_test_action<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<tests::TestAction> {# ! [ allow ( non_snake_case , unused ) ]    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = slice_eq(__input, __state, __pos, "!debug");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_space(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, _) => {
                                match __parse_value(__input, __state, __pos) {
                                    Matched(pos, _) => Matched(pos, ()),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    Matched(__pos, {
                        tests::TestAction::Debug
                    })
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "!fixme");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_space(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        match __parse_value(__input, __state, __pos) {
                                            Matched(pos, _) => Matched(pos, ()),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            Matched(__pos, {
                                tests::TestAction::Skip
                            })
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "!ignore");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    Matched(__pos, {
                                        tests::TestAction::Ignore
                                    })
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = __parse_value(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, value) => {
                                        Matched(__pos, {
                                            tests::TestAction::Expect(value)
                                        })
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

pub fn value<'input>(__input: &'input str) -> ParseResult<values::Value> {# ! [ allow ( non_snake_case , unused ) ]    let mut __state = ParseState::new();
    match __parse_value(__input, &mut __state, 0) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError {
        line: __line,
        column: __col,
        offset: __state.max_err_pos,
        expected: __state.expected,
    })
}

pub fn script<'input>(__input: &'input str) -> ParseResult<Vec<values::Value>> {# ! [ allow ( non_snake_case , unused ) ]    let mut __state = ParseState::new();
    match __parse_script(__input, &mut __state, 0) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError {
        line: __line,
        column: __col,
        offset: __state.max_err_pos,
        expected: __state.expected,
    })
}

pub fn tests<'input>(__input: &'input str) -> ParseResult<Vec<tests::TestCase>> {# ! [ allow ( non_snake_case , unused ) ]    let mut __state = ParseState::new();
    match __parse_tests(__input, &mut __state, 0) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError {
        line: __line,
        column: __col,
        offset: __state.max_err_pos,
        expected: __state.expected,
    })
}

pub fn test<'input>(__input: &'input str) -> ParseResult<tests::TestCase> {# ! [ allow ( non_snake_case , unused ) ]    let mut __state = ParseState::new();
    match __parse_test(__input, &mut __state, 0) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError {
        line: __line,
        column: __col,
        offset: __state.max_err_pos,
        expected: __state.expected,
    })
}
